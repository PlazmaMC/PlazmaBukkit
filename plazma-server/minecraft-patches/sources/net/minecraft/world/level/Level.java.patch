--- a/net/minecraft/world/level/Level.java
+++ b/net/minecraft/world/level/Level.java
@@ -108,13 +_,6 @@
     public static final ResourceKey<Level> OVERWORLD = ResourceKey.create(Registries.DIMENSION, ResourceLocation.withDefaultNamespace("overworld"));
     public static final ResourceKey<Level> NETHER = ResourceKey.create(Registries.DIMENSION, ResourceLocation.withDefaultNamespace("the_nether"));
     public static final ResourceKey<Level> END = ResourceKey.create(Registries.DIMENSION, ResourceLocation.withDefaultNamespace("the_end"));
-    public static final int MAX_LEVEL_SIZE = 30000000;
-    public static final int LONG_PARTICLE_CLIP_RANGE = 512;
-    public static final int SHORT_PARTICLE_CLIP_RANGE = 32;
-    public static final int MAX_BRIGHTNESS = 15;
-    public static final int TICKS_PER_DAY = 24000;
-    public static final int MAX_ENTITY_SPAWN_Y = 20000000;
-    public static final int MIN_ENTITY_SPAWN_Y = -20000000;
     public final List<TickingBlockEntity> blockEntityTickers = Lists.newArrayList(); // Paper - public
     protected final NeighborUpdater neighborUpdater;
     private final List<TickingBlockEntity> pendingBlockEntityTickers = Lists.newArrayList();
@@ -123,7 +_,7 @@
     private final boolean isDebug;
     private int skyDarken;
     protected int randValue = RandomSource.create().nextInt();
-    protected final int addend = 1013904223;
+    //protected final int addend = 1013904223;
     protected float oRainLevel;
     public float rainLevel;
     protected float oThunderLevel;
@@ -144,6 +_,7 @@
     // CraftBukkit start Added the following
     private final CraftWorld world;
     public boolean pvpMode;
+    @Nullable // Plazma - Null safety
     public org.bukkit.generator.ChunkGenerator generator;
 
     public boolean preventPoiUpdated = false; // CraftBukkit - SPIGOT-5710
@@ -152,6 +_,7 @@
     public boolean isBlockPlaceCancelled = false; // Paper - prevent calling cleanup logic when undoing a block place upon a cancelled BlockPlaceEvent
     public Map<BlockPos, org.bukkit.craftbukkit.block.CraftBlockState> capturedBlockStates = new java.util.LinkedHashMap<>(); // Paper
     public Map<BlockPos, BlockEntity> capturedTileEntities = new java.util.LinkedHashMap<>(); // Paper - Retain block place order when capturing blockstates
+    @Nullable // Plazma - Null safety
     public List<net.minecraft.world.entity.item.ItemEntity> captureDrops;
     public final it.unimi.dsi.fastutil.objects.Object2LongOpenHashMap<SpawnCategory> ticksPerSpawnCategory = new it.unimi.dsi.fastutil.objects.Object2LongOpenHashMap<>();
     // Paper start
@@ -169,13 +_,22 @@
     }
     // Paper end - add paper world config
 
+    // Plazma start - Configurable Plazma
+    private final org.plazmamc.plazma.configurations.WorldConfiguration plazmaConfig;
+    public org.plazmamc.plazma.configurations.WorldConfiguration plazmaConfig() {
+        return this.plazmaConfig;
+    }
+    // Plazma end - Configurable Plazma
+
     public final io.papermc.paper.antixray.ChunkPacketBlockController chunkPacketBlockController; // Paper - Anti-Xray
     public final org.purpurmc.purpur.PurpurWorldConfig purpurConfig; // Purpur - Purpur config files
+    @Nullable // Plazma - Null safety
     public static BlockPos lastPhysicsProblem; // Spigot
     private org.spigotmc.TickLimiter entityLimiter;
     private org.spigotmc.TickLimiter tileLimiter;
-    private int tileTickPosition;
-    public final Map<ServerExplosion.CacheKey, Float> explosionDensityCache = new HashMap<>(); // Paper - Optimize explosions
+    //private int tileTickPosition;
+    final Map<ServerExplosion.CacheKey, Float> explosionDensityCache = new HashMap<>(); public final void clearExplosionDensityCache() { this.explosionDensityCache.clear(); } // Paper - Optimize explosions // Plazma - public -> package-private
+    @Nullable // Plazma - Null safety
     public java.util.ArrayDeque<net.minecraft.world.level.block.RedstoneTorchBlock.Toggle> redstoneUpdateInfos; // Paper - Faster redstone torch rapid clock removal; Move from Map in BlockRedstoneTorch to here
 
     // Purpur start - Add adjustable breeding cooldown to config
@@ -197,21 +_,12 @@
         this.playerBreedingCooldowns.put(new BreedingCooldownPair(player, animalType), new Object());
     }
 
-    private static final class BreedingCooldownPair {
-        private final java.util.UUID playerUUID;
-        private final Class<? extends net.minecraft.world.entity.animal.Animal> animalType;
-
-        public BreedingCooldownPair(java.util.UUID playerUUID, Class<? extends net.minecraft.world.entity.animal.Animal> animalType) {
-            this.playerUUID = playerUUID;
-            this.animalType = animalType;
-        }
-
+    private record BreedingCooldownPair(java.util.UUID playerUUID, Class<? extends net.minecraft.world.entity.animal.Animal> animalType) { // Plazma - Use record instead
         @Override
         public boolean equals(Object o) {
             if (this == o) return true;
-            if (o == null || getClass() != o.getClass()) return false;
-            BreedingCooldownPair that = (BreedingCooldownPair) o;
-            return playerUUID.equals(that.playerUUID) && animalType.equals(that.animalType);
+            if (!(o instanceof BreedingCooldownPair(java.util.UUID uuid, Class<? extends net.minecraft.world.entity.animal.Animal> type))) return false; // Plazma - Use record instead
+            return playerUUID.equals(uuid) && animalType.equals(type); // Plazma - Use record instead
         }
 
         @Override
@@ -219,7 +_,6 @@
             return java.util.Objects.hash(playerUUID, animalType);
         }
     }
-    // Purpur end - Add adjustable breeding cooldown to config
 
     public CraftWorld getWorld() {
         return this.world;
@@ -228,12 +_,14 @@
     public CraftServer getCraftServer() {
         return (CraftServer) Bukkit.getServer();
     }
+
     // Paper start - Use getChunkIfLoadedImmediately
     @Override
     public boolean hasChunk(int chunkX, int chunkZ) {
         return this.getChunkIfLoaded(chunkX, chunkZ) != null;
     }
     // Paper end - Use getChunkIfLoadedImmediately
+
     // Paper start - per world ticks per spawn
     private int getTicksPerSpawn(SpawnCategory spawnCategory) {
         final int perWorld = this.paperConfig().entities.spawning.ticksPerSpawn.getInt(CraftSpawnCategory.toNMS(spawnCategory));
@@ -248,12 +_,13 @@
     public abstract ResourceKey<LevelStem> getTypeKey();
 
     // Paper start - rewrite chunk system
+    @Nullable // Plazma - Null safety
     private ca.spottedleaf.moonrise.patches.chunk_system.level.entity.EntityLookup entityLookup;
     private final ca.spottedleaf.concurrentutil.map.ConcurrentLong2ReferenceChainedHashTable<ca.spottedleaf.moonrise.patches.chunk_system.level.chunk.ChunkData> chunkData = new ca.spottedleaf.concurrentutil.map.ConcurrentLong2ReferenceChainedHashTable<>();
 
     @Override
     public final ca.spottedleaf.moonrise.patches.chunk_system.level.entity.EntityLookup moonrise$getEntityLookup() {
-        return this.entityLookup;
+        return java.util.Objects.requireNonNull(this.entityLookup, "Entity lookup not initialised"); // Plazma - Null safety
     }
 
     @Override
@@ -366,7 +_,7 @@
      */
     @Override
     public ChunkAccess getChunk(final int x, final int z, final ChunkStatus status) {
-        return ((Level)(Object)this).getChunk(x, z, status, true);
+        return this.getChunk(x, z, status, true); // Plazma - Remove unnecessary type casting
     }
 
     @Override
@@ -879,11 +_,11 @@
         boolean isDebug,
         long biomeZoomSeed,
         int maxChainedNeighborUpdates,
-        org.bukkit.generator.ChunkGenerator gen, // CraftBukkit
-        org.bukkit.generator.BiomeProvider biomeProvider, // CraftBukkit
+        org.bukkit.generator.@org.jspecify.annotations.Nullable ChunkGenerator gen, // CraftBukkit
+        org.bukkit.generator.@org.jspecify.annotations.Nullable BiomeProvider biomeProvider, // CraftBukkit
         org.bukkit.World.Environment env, // CraftBukkit
-        java.util.function.Function<org.spigotmc.SpigotWorldConfig, // Spigot - create per world config
-        io.papermc.paper.configuration.WorldConfiguration> paperWorldConfigCreator, // Paper - create paper world config
+        java.util.function.Function<org.spigotmc.SpigotWorldConfig, io.papermc.paper.configuration.WorldConfiguration> paperWorldConfigCreator, // Paper - create paper world config
+        java.util.function.Supplier<org.plazmamc.plazma.configurations.WorldConfiguration> plazmaWorldConfigSupplier, // Plazma - Plazma config files
         java.util.concurrent.Executor executor // Paper - Anti-Xray
     ) {
         // Paper start - getblock optimisations - cache world height/sections
@@ -897,6 +_,7 @@
         // Paper end - getblock optimisations - cache world height/sections
         this.spigotConfig = new org.spigotmc.SpigotWorldConfig(((net.minecraft.world.level.storage.PrimaryLevelData) levelData).getLevelName()); // Spigot
         this.paperConfig = paperWorldConfigCreator.apply(this.spigotConfig); // Paper - create paper world config
+        this.plazmaConfig = plazmaWorldConfigSupplier.get(); // Plazma - Plazma config files
         this.purpurConfig = new org.purpurmc.purpur.PurpurWorldConfig(((net.minecraft.world.level.storage.PrimaryLevelData) levelData).getLevelName(), env); // Purpur - Purpur config files
         this.playerBreedingCooldowns = this.getNewBreedingCooldownCache(); // Purpur - Add adjustable breeding cooldown to config
         this.generator = gen;
@@ -990,7 +_,7 @@
             return true;
         }
 
-        voxelshape = voxelshape.move((double) position.getX(), (double) position.getY(), (double) position.getZ());
+        voxelshape = voxelshape.move(position.getX(), position.getY(), position.getZ()); // Plazma - Remove unnecessary type casting
         if (voxelshape.isEmpty()) {
             return true;
         }
@@ -1160,130 +_,110 @@
             return true;
         }
         // CraftBukkit end
+
+        // Plazma start - Improve code quality
         if (this.isOutsideBuildHeight(pos)) {
             return false;
-        } else if (!this.isClientSide && this.isDebug()) {
+        }
+
+        if (!this.isClientSide && this.isDebug()) {
             return false;
-        } else {
-            LevelChunk chunkAt = this.getChunkAt(pos);
-            Block block = state.getBlock();
-            // CraftBukkit start - capture blockstates
-            boolean captured = false;
-            if (this.captureBlockStates && !this.capturedBlockStates.containsKey(pos)) {
-                CraftBlockState blockstate = (CraftBlockState) world.getBlockAt(pos.getX(), pos.getY(), pos.getZ()).getState(); // Paper - use CB getState to get a suitable snapshot
-                blockstate.setFlag(flags); // Paper - set flag
-                this.capturedBlockStates.put(pos.immutable(), blockstate);
-                captured = true;
+        }
+
+        LevelChunk chunkAt = this.getChunkAt(pos);
+        // CraftBukkit start - capture blockstates
+        boolean captured = false;
+        if (this.captureBlockStates && !this.capturedBlockStates.containsKey(pos)) {
+            CraftBlockState blockstate = (CraftBlockState) world.getBlockAt(pos.getX(), pos.getY(), pos.getZ()).getState(); // Paper - use CB getState to get a suitable snapshot
+            blockstate.setFlag(flags); // Paper - set flag
+            this.capturedBlockStates.put(pos.immutable(), blockstate);
+            captured = true;
+        }
+        // CraftBukkit end
+
+        BlockState blockState = chunkAt.setBlockState(pos, state, (flags & 64) != 0, (flags & 1024) == 0); // CraftBukkit custom NO_PLACE flag
+        this.chunkPacketBlockController.onBlockChange(this, pos, state, blockState, flags, recursionLeft); // Paper - Anti-Xray
+
+        if (blockState == null) {
+            // CraftBukkit start - remove blockstate if failed (or the same)
+            if (this.captureBlockStates && captured) {
+                this.capturedBlockStates.remove(pos);
             }
             // CraftBukkit end
-
-            BlockState blockState = chunkAt.setBlockState(pos, state, (flags & 64) != 0, (flags & 1024) == 0); // CraftBukkit custom NO_PLACE flag
-            this.chunkPacketBlockController.onBlockChange(this, pos, state, blockState, flags, recursionLeft); // Paper - Anti-Xray
-
-            if (blockState == null) {
-                // CraftBukkit start - remove blockstate if failed (or the same)
-                if (this.captureBlockStates && captured) {
-                    this.capturedBlockStates.remove(pos);
-                }
-                // CraftBukkit end
-                return false;
-            } else {
-                BlockState blockState1 = this.getBlockState(pos);
-                /*
-                if (blockState1 == state) {
-                    if (blockState != blockState1) {
-                        this.setBlocksDirty(pos, blockState, blockState1);
-                    }
-
-                    if ((flags & 2) != 0
-                        && (!this.isClientSide || (flags & 4) == 0)
-                        && (this.isClientSide || chunkAt.getFullStatus() != null && chunkAt.getFullStatus().isOrAfter(FullChunkStatus.BLOCK_TICKING))) {
-                        this.sendBlockUpdated(pos, blockState, state, flags);
-                    }
-
-                    if ((flags & 1) != 0) {
-                        this.blockUpdated(pos, blockState.getBlock());
-                        if (!this.isClientSide && state.hasAnalogOutputSignal()) {
-                            this.updateNeighbourForOutputSignal(pos, block);
-                        }
-                    }
-
-                    if ((flags & 16) == 0 && recursionLeft > 0) {
-                        int i = flags & -34;
-                        blockState.updateIndirectNeighbourShapes(this, pos, i, recursionLeft - 1);
-                        state.updateNeighbourShapes(this, pos, i, recursionLeft - 1);
-                        state.updateIndirectNeighbourShapes(this, pos, i, recursionLeft - 1);
-                    }
-
-                    this.onBlockStateChange(pos, blockState, blockState1);
-                }
-                */
-
-                // CraftBukkit start
-                if (!this.captureBlockStates) { // Don't notify clients or update physics while capturing blockstates
-                    // Modularize client and physic updates
-                    // Spigot start
-                    try {
-                        this.notifyAndUpdatePhysics(pos, chunkAt, blockState, state, blockState1, flags, recursionLeft);
-                    } catch (StackOverflowError ex) {
-                        Level.lastPhysicsProblem = new BlockPos(pos);
-                    }
-                    // Spigot end
-                }
-                // CraftBukkit end
-
+            return false;
+        } else {
+            BlockState blockState1 = this.getBlockState(pos);
+
+            // CraftBukkit start
+            if (this.captureBlockStates) { // Don't notify clients or update physics while capturing blockstates
                 return true;
             }
+
+            // Modularize client and physic updates
+            // Spigot start
+            try {
+                this.notifyAndUpdatePhysics(pos, chunkAt, blockState, state, blockState1, flags, recursionLeft);
+            } catch (StackOverflowError ex) {
+                Level.lastPhysicsProblem = new BlockPos(pos);
+            }
+            // Spigot end
+            // CraftBukkit end
+
+            return true;
         }
+        // Plazma end - Improve code quality
     }
 
     // CraftBukkit start - Split off from above in order to directly send client and physic updates
-    public void notifyAndUpdatePhysics(BlockPos blockposition, LevelChunk chunk, BlockState oldBlock, BlockState newBlock, BlockState actualBlock, int i, int j) {
-        BlockState iblockdata = newBlock;
-        BlockState iblockdata1 = oldBlock;
-        BlockState iblockdata2 = actualBlock;
-        if (iblockdata2 == iblockdata) {
-            if (iblockdata1 != iblockdata2) {
-                this.setBlocksDirty(blockposition, iblockdata1, iblockdata2);
-            }
-
-            if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || (chunk.getFullStatus() != null && chunk.getFullStatus().isOrAfter(FullChunkStatus.FULL)))) { // allow chunk to be null here as chunk.isReady() is false when we send our notification during block placement // Paper - rewrite chunk system - change from ticking to full
-                this.sendBlockUpdated(blockposition, iblockdata1, iblockdata, i);
-            }
-
-            if ((i & 1) != 0) {
-                this.blockUpdated(blockposition, iblockdata1.getBlock());
-                if (!this.isClientSide && iblockdata.hasAnalogOutputSignal()) {
-                    this.updateNeighbourForOutputSignal(blockposition, newBlock.getBlock());
-                }
-            }
-
-            if ((i & 16) == 0 && j > 0) {
-                int k = i & -34;
-
-                // CraftBukkit start
-                iblockdata1.updateIndirectNeighbourShapes(this, blockposition, k, j - 1); // Don't call an event for the old block to limit event spam
-                CraftWorld world = ((ServerLevel) this).getWorld();
-                boolean cancelledUpdates = false; // Paper - Fix block place logic
-                if (world != null && ((ServerLevel)this).hasPhysicsEvent) { // Paper - BlockPhysicsEvent
-                    BlockPhysicsEvent event = new BlockPhysicsEvent(world.getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()), CraftBlockData.fromData(iblockdata));
-                    this.getCraftServer().getPluginManager().callEvent(event);
-
-                    cancelledUpdates = event.isCancelled(); // Paper - Fix block place logic
-                }
-                // CraftBukkit end
-                if (!cancelledUpdates) { // Paper - Fix block place logic
-                    iblockdata.updateNeighbourShapes(this, blockposition, k, j - 1);
-                    iblockdata.updateIndirectNeighbourShapes(this, blockposition, k, j - 1);
-                } // Paper - Fix block place logic
-            }
-
-            // CraftBukkit start - SPIGOT-5710
-            if (!this.preventPoiUpdated) {
-                this.onBlockStateChange(blockposition, iblockdata1, iblockdata2);
+    public void notifyAndUpdatePhysics(BlockPos blockPos, LevelChunk chunk, BlockState oldBlock, BlockState newBlock, BlockState actualBlock, int i, int j) {
+        // Plazma start - Improve code quality
+        if (actualBlock != newBlock) {
+            return;
+        }
+
+        if (oldBlock != actualBlock) {
+            this.setBlocksDirty(blockPos, oldBlock, actualBlock);
+        }
+
+        if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || (chunk.getFullStatus() != null && chunk.getFullStatus().isOrAfter(FullChunkStatus.FULL)))) { // allow chunk to be null here as chunk.isReady() is false when we send our notification during block placement // Paper - rewrite chunk system - change from ticking to full
+            this.sendBlockUpdated(blockPos, oldBlock, newBlock, i);
+        }
+
+        if ((i & 1) != 0) {
+            this.blockUpdated(blockPos, oldBlock.getBlock());
+            if (!this.isClientSide && newBlock.hasAnalogOutputSignal()) {
+                this.updateNeighbourForOutputSignal(blockPos, newBlock.getBlock());
+            }
+        }
+
+        if ((i & 16) == 0 && j > 0) {
+            int k = i & -34;
+
+            // CraftBukkit start
+            oldBlock.updateIndirectNeighbourShapes(this, blockPos, k, j - 1); // Don't call an event for the old block to limit event spam
+            boolean cancelledUpdates = false; // Paper - Fix block place logic
+
+            final CraftWorld world = this.getWorld(); // Plazma - Remove unnecessary type casting
+            if (world != null && ((ServerLevel)this).hasPhysicsEvent) { // Paper - BlockPhysicsEvent
+                BlockPhysicsEvent event = new BlockPhysicsEvent(world.getBlockAt(blockPos.getX(), blockPos.getY(), blockPos.getZ()), CraftBlockData.fromData(newBlock));
+                this.getCraftServer().getPluginManager().callEvent(event);
+
+                cancelledUpdates = event.isCancelled(); // Paper - Fix block place logic
             }
             // CraftBukkit end
-        }
+
+            if (!cancelledUpdates) { // Paper - Fix block place logic
+                newBlock.updateNeighbourShapes(this, blockPos, k, j - 1);
+                newBlock.updateIndirectNeighbourShapes(this, blockPos, k, j - 1);
+            } // Paper - Fix block place logic
+        }
+
+        // CraftBukkit start - SPIGOT-5710
+        if (!this.preventPoiUpdated) {
+            this.onBlockStateChange(blockPos, oldBlock, actualBlock);
+        }
+        // CraftBukkit end
+        // Plazma end - Improve code quality
     }
     // CraftBukkit end
 
@@ -1518,21 +_,19 @@
         int tickedEntities = 0; // Paper - rewrite chunk system
         var toRemove = new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<TickingBlockEntity>(); // Paper - Fix MC-117075; use removeAll
         toRemove.add(null); // Paper - Fix MC-117075
-        for (tileTickPosition = 0; tileTickPosition < this.blockEntityTickers.size(); tileTickPosition++) { // Paper - Disable tick limiters
-            this.tileTickPosition = (this.tileTickPosition < this.blockEntityTickers.size()) ? this.tileTickPosition : 0;
-            TickingBlockEntity tickingBlockEntity = this.blockEntityTickers.get(this.tileTickPosition);
-            // Spigot end
+        // Plazma start - Improve code quality
+        for (TickingBlockEntity tickingBlockEntity : this.blockEntityTickers) { // Paper - Disable tick limiters
             if (tickingBlockEntity.isRemoved()) {
                 toRemove.add(tickingBlockEntity); // Paper - Fix MC-117075; use removeAll
-            } else if (runsNormally && this.shouldTickBlocksAt(tickingBlockEntity.getPos())) {
-                tickingBlockEntity.tick();
-                // Paper start - rewrite chunk system
-                if ((++tickedEntities & 7) == 0) {
-                    ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)(Level)(Object)this).moonrise$midTickTasks();
-                }
-                // Paper end - rewrite chunk system
+                continue;
             }
+
+            if (!runsNormally || this.shouldTickBlocksAt(tickingBlockEntity.getPos())) continue;
+
+            tickingBlockEntity.tick();
+            if ((++tickedEntities & 7) == 0) this.moonrise$midTickTasks(); // Paper - rewrite chunk system
         }
+        // Plazma end - Improve code quality
         this.blockEntityTickers.removeAll(toRemove); // Paper - Fix MC-117075
 
         this.tickingBlockEntities = false;
@@ -1561,11 +_,11 @@
             return false;
         // Paper start - optimise collisions
         final int flags = entity == null ? (ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_BORDER | ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_ONLY) : ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_ONLY;
-        if (ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getCollisionsForBlocksOrWorldBorder((Level)(Object)this, entity, box, null, null, flags, null)) {
+        if (ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getCollisionsForBlocksOrWorldBorder(this, entity, box, null, null, flags, null)) { // Plazma - Remove unnecessary type casting
             return false;
         }
 
-        return !ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getEntityHardCollisions((Level)(Object)this, entity, box, null, flags, null);
+        return !ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getEntityHardCollisions(this, entity, box, null, flags, null); // Plazma - Remove unnecessary type casting
         // Paper end - optimise collisions
     }
     // Paper end - Option to prevent armor stands from doing entity lookups
@@ -1750,7 +_,7 @@
     public void updateSkyBrightness() {
         double d = 1.0 - this.getRainLevel(1.0F) * 5.0F / 16.0;
         double d1 = 1.0 - this.getThunderLevel(1.0F) * 5.0F / 16.0;
-        double d2 = 0.5 + 2.0 * Mth.clamp((double)Mth.cos(this.getTimeOfDay(1.0F) * (float) (Math.PI * 2)), -0.25, 0.25);
+        double d2 = 0.5 + 2.0 * Mth.clamp(Mth.cos(this.getTimeOfDay(1.0F) * (float) (Math.PI * 2)), -0.25, 0.25); // Plazma - Remove unnecessary type casting
         this.skyDarken = (int)((1.0 - d2 * d * d1) * 11.0);
     }
 
@@ -1774,12 +_,13 @@
     }
 
     protected void prepareWeather() {
-        if (this.levelData.isRaining()) {
-            this.rainLevel = 1.0F;
-            if (this.levelData.isThundering()) {
-                this.thunderLevel = 1.0F;
-            }
-        }
+        // Plazma start - Improve code quality
+        if (!this.levelData.isRaining()) return;
+        this.rainLevel = 1F;
+
+        if (!this.levelData.isThundering()) return;
+        this.thunderLevel = 1F;
+        // Plazma end - Improve code quality
     }
 
     @Override
@@ -1796,15 +_,11 @@
     @Override
     public List<Entity> getEntities(@Nullable Entity entity, AABB boundingBox, Predicate<? super Entity> predicate) {
         Profiler.get().incrementCounter("getEntities");
-        List<Entity> list = Lists.newArrayList();
 
         // Paper start - rewrite chunk system
         final List<Entity> ret = new java.util.ArrayList<>();
-
-        ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this).moonrise$getEntityLookup().getEntities(entity, boundingBox, ret, predicate);
-
-        ca.spottedleaf.moonrise.common.PlatformHooks.get().addToGetEntities((Level)(Object)this, entity, boundingBox, predicate, ret);
-
+        this.moonrise$getEntityLookup().getEntities(entity, boundingBox, ret, predicate); // Plazma - Remove unnecessary type casting
+        ca.spottedleaf.moonrise.common.PlatformHooks.get().addToGetEntities(this, entity, boundingBox, predicate, ret); // Plazma - Remove unnecessary type casting
         return ret;
         // Paper end - rewrite chunk system
     }
@@ -1821,78 +_,68 @@
     }
 
     // Paper start - rewrite chunk system
-    public <T extends Entity> void getEntities(final EntityTypeTest<Entity, T> entityTypeTest,
-                                               final AABB boundingBox, final Predicate<? super T> predicate,
-                                               final List<? super T> into, final int maxCount) {
+    public <T extends Entity> void getEntities(
+        // Plazma start - Improve code quality
+        final @Nullable EntityTypeTest<Entity, T> entityTypeTest,
+        final AABB boundingBox,
+        final @Nullable Predicate<? super T> predicate,
+        final @Nullable List<? super T> into,
+        final int maxCount
+    ) {
         Profiler.get().incrementCounter("getEntities");
 
         if (entityTypeTest instanceof net.minecraft.world.entity.EntityType<T> byType) {
             if (maxCount != Integer.MAX_VALUE) {
-                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this).moonrise$getEntityLookup().getEntities(byType, boundingBox, into, predicate, maxCount);
-                ca.spottedleaf.moonrise.common.PlatformHooks.get().addToGetEntities((Level)(Object)this, entityTypeTest, boundingBox, predicate, into, maxCount);
-                return;
+                this.moonrise$getEntityLookup().getEntities(byType, boundingBox, into, predicate, maxCount);
             } else {
-                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this).moonrise$getEntityLookup().getEntities(byType, boundingBox, into, predicate);
-                ca.spottedleaf.moonrise.common.PlatformHooks.get().addToGetEntities((Level)(Object)this, entityTypeTest, boundingBox, predicate, into, maxCount);
-                return;
+                this.moonrise$getEntityLookup().getEntities(byType, boundingBox, into, predicate);
             }
+            ca.spottedleaf.moonrise.common.PlatformHooks.get().addToGetEntities(this, entityTypeTest, boundingBox, predicate, into, maxCount);
+            return;
         }
 
         if (entityTypeTest == null) {
             if (maxCount != Integer.MAX_VALUE) {
-                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this).moonrise$getEntityLookup().getEntities((Entity)null, boundingBox, (List)into, (Predicate)predicate, maxCount);
-                ca.spottedleaf.moonrise.common.PlatformHooks.get().addToGetEntities((Level)(Object)this, entityTypeTest, boundingBox, predicate, into, maxCount);
-                return;
+                this.moonrise$getEntityLookup().getEntities(null, boundingBox, into, predicate, maxCount);
             } else {
-                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this).moonrise$getEntityLookup().getEntities((Entity)null, boundingBox, (List)into, (Predicate)predicate);
-                ca.spottedleaf.moonrise.common.PlatformHooks.get().addToGetEntities((Level)(Object)this, entityTypeTest, boundingBox, predicate, into, maxCount);
-                return;
+                this.moonrise$getEntityLookup().getEntities(null, boundingBox, into, predicate);
             }
+            ca.spottedleaf.moonrise.common.PlatformHooks.get().addToGetEntities(this, null, boundingBox, predicate, into, maxCount);
+            return;
         }
 
         final Class<? extends Entity> base = entityTypeTest.getBaseClass();
 
         final Predicate<? super T> modifiedPredicate;
         if (predicate == null) {
-            modifiedPredicate = (final T obj) -> {
-                return entityTypeTest.tryCast(obj) != null;
-            };
+            modifiedPredicate = (obj) -> entityTypeTest.tryCast(obj) != null;
         } else {
-            modifiedPredicate = (final Entity obj) -> {
+            modifiedPredicate = (obj) -> {
                 final T casted = entityTypeTest.tryCast(obj);
-                if (casted == null) {
-                    return false;
-                }
-
-                return predicate.test(casted);
+                return casted != null && predicate.test(casted);
             };
         }
 
-        if (base == null || base == Entity.class) {
+        if (base == Entity.class) {
             if (maxCount != Integer.MAX_VALUE) {
-                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this).moonrise$getEntityLookup().getEntities((Entity)null, boundingBox, (List)into, (Predicate)modifiedPredicate, maxCount);
-                ca.spottedleaf.moonrise.common.PlatformHooks.get().addToGetEntities((Level)(Object)this, entityTypeTest, boundingBox, predicate, into, maxCount);
-                return;
+                this.moonrise$getEntityLookup().getEntities(null, boundingBox, into, modifiedPredicate, maxCount);
             } else {
-                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this).moonrise$getEntityLookup().getEntities((Entity)null, boundingBox, (List)into, (Predicate)modifiedPredicate);
-                ca.spottedleaf.moonrise.common.PlatformHooks.get().addToGetEntities((Level)(Object)this, entityTypeTest, boundingBox, predicate, into, maxCount);
-                return;
+                this.moonrise$getEntityLookup().getEntities(null, boundingBox, into, modifiedPredicate);
             }
         } else {
             if (maxCount != Integer.MAX_VALUE) {
-                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this).moonrise$getEntityLookup().getEntities(base, null, boundingBox, (List)into, (Predicate)modifiedPredicate, maxCount);
-                ca.spottedleaf.moonrise.common.PlatformHooks.get().addToGetEntities((Level)(Object)this, entityTypeTest, boundingBox, predicate, into, maxCount);
-                return;
+                this.moonrise$getEntityLookup().getEntities(base, null, boundingBox, (List) into, (Predicate) modifiedPredicate, maxCount);
             } else {
-                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this).moonrise$getEntityLookup().getEntities(base, null, boundingBox, (List)into, (Predicate)modifiedPredicate);
-                ca.spottedleaf.moonrise.common.PlatformHooks.get().addToGetEntities((Level)(Object)this, entityTypeTest, boundingBox, predicate, into, maxCount);
-                return;
+                this.moonrise$getEntityLookup().getEntities(base, null, boundingBox, (List) into, (Predicate) modifiedPredicate);
             }
         }
+
+        ca.spottedleaf.moonrise.common.PlatformHooks.get().addToGetEntities(this, entityTypeTest, boundingBox, predicate, into, maxCount);
+        // Plazma end - Improve code quality
     }
 
     public org.bukkit.entity.Entity[] getChunkEntities(int chunkX, int chunkZ) {
-        ca.spottedleaf.moonrise.patches.chunk_system.level.entity.ChunkEntitySlices slices = ((ServerLevel)this).moonrise$getEntityLookup().getChunk(chunkX, chunkZ);
+        ca.spottedleaf.moonrise.patches.chunk_system.level.entity.ChunkEntitySlices slices = this.moonrise$getEntityLookup().getChunk(chunkX, chunkZ); // Plazma - Remove unnecessary type casting
         if (slices == null) {
             return new org.bukkit.entity.Entity[0];
         }
@@ -1900,7 +_,7 @@
         List<org.bukkit.entity.Entity> ret = new java.util.ArrayList<>();
         for (Entity entity : slices.getAllEntities()) {
             org.bukkit.entity.Entity bukkit = entity.getBukkitEntity();
-            if (bukkit != null && bukkit.isValid()) {
+            if (bukkit.isValid()) { // Plazma - Not nullable
                 ret.add(bukkit);
             }
         }
@@ -2032,18 +_,20 @@
     public void updateNeighbourForOutputSignal(BlockPos pos, Block block) {
         for (Direction direction : Direction.Plane.HORIZONTAL) {
             BlockPos blockPos = pos.relative(direction);
-            if (this.hasChunkAt(blockPos)) {
-                BlockState blockState = this.getBlockState(blockPos);
-                if (blockState.is(Blocks.COMPARATOR)) {
-                    this.neighborChanged(blockState, blockPos, block, null, false);
-                } else if (blockState.isRedstoneConductor(this, blockPos)) {
-                    blockPos = blockPos.relative(direction);
-                    blockState = this.getBlockState(blockPos);
-                    if (blockState.is(Blocks.COMPARATOR)) {
-                        this.neighborChanged(blockState, blockPos, block, null, false);
-                    }
+            // Plazma start - Improve code quality
+            if (!this.hasChunkAt(blockPos)) continue;
+
+            BlockState state = this.getBlockState(blockPos);
+            if (state.is(Blocks.COMPARATOR)) {
+                this.neighborChanged(state, blockPos, block, null, false);
+            } else if (state.isRedstoneConductor(this, blockPos)) {
+                blockPos = blockPos.relative(direction);
+                state = this.getBlockState(blockPos);
+                if (state.is(Blocks.COMPARATOR)) {
+                    this.neighborChanged(state, blockPos, block, null, false);
                 }
             }
+            // Plazma end - Improve code quality
         }
     }
 
@@ -2145,16 +_,7 @@
 
     public abstract FuelValues fuelValues();
 
-    // Paper start - optimize redstone (Alternate Current)
-    public alternate.current.wire.WireHandler getWireHandler() {
-        // This method is overridden in ServerLevel.
-        // Since Paper is a server platform there is no risk
-        // of this implementation being called. It is here
-        // only so this method can be called without casting
-        // an instance of Level to ServerLevel.
-        return null;
-    }
-    // Paper end - optimize redstone (Alternate Current)
+    public abstract alternate.current.wire.WireHandler getWireHandler(); // Paper - optimize redstone (Alternate Current) // Plazma - Use abstract instead
 
     public static enum ExplosionInteraction implements StringRepresentable {
         NONE("none"),
