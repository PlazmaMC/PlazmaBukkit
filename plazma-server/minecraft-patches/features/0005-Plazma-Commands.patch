From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: IPECTER <ipectert@gmail.com>
Date: Mon, 15 Sep 2025 01:06:59 +0900
Subject: [PATCH] Plazma Commands


diff --git a/net/minecraft/server/ReloadableServerResources.java b/net/minecraft/server/ReloadableServerResources.java
index c891715968193f2ab4579b4a2b4aeeae6a210070..d1257be5fb82fffe6ec5fb9642670d6b9aca2175 100644
--- a/net/minecraft/server/ReloadableServerResources.java
+++ b/net/minecraft/server/ReloadableServerResources.java
@@ -41,6 +41,7 @@ public class ReloadableServerResources {
         this.commands = new Commands(commandSelection, CommandBuildContext.simple(registries, enabledFeatures), true); // Paper - Brigadier Command API - use modern alias registration
         io.papermc.paper.command.brigadier.PaperCommands.INSTANCE.setDispatcher(this.commands, CommandBuildContext.simple(registries, enabledFeatures)); // Paper - Brigadier Command API
         io.papermc.paper.command.PaperCommands.registerCommands(); // Paper
+        org.plazmamc.plazma.command.PlazmaCommands.registerCommands(); // Plazma
         this.advancements = new ServerAdvancementManager(registries);
         this.functionLibrary = new ServerFunctionLibrary(functionCompilationLevel, this.commands.getDispatcher());
     }
diff --git a/net/minecraft/server/dedicated/DedicatedServer.java b/net/minecraft/server/dedicated/DedicatedServer.java
index 8068512cb2baa8b5ef11b21eca008ecaa519ce9b..9ea4012e7e13c0c4a4496787b9b8755eb93bca37 100644
--- a/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/net/minecraft/server/dedicated/DedicatedServer.java
@@ -186,6 +186,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         org.spigotmc.WatchdogThread.doStart(org.spigotmc.SpigotConfig.timeoutTime, org.spigotmc.SpigotConfig.restartOnCrash); // Paper - start watchdog thread
         thread.start(); // Paper - Enhance console tab completions for brigadier commands; start console thread after MinecraftServer.console & PaperConfig are initialized
         io.papermc.paper.command.PaperCommands.registerCommands(this); // Paper - setup /paper command
+        org.plazmamc.plazma.command.PlazmaCommands.registerCommands(this); // Plazma - setup /plazma command
         this.server.spark.registerCommandBeforePlugins(this.server); // Paper - spark
         com.destroystokyo.paper.Metrics.PaperMetrics.startMetrics(); // Paper - start metrics
         // Purpur start - Purpur config files
diff --git a/org/plazmamc/plazma/command/PlazmaCommand.java b/org/plazmamc/plazma/command/PlazmaCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..56a1f96cc3530101fe76ee8fd68927ec8bac4bd0
--- /dev/null
+++ b/org/plazmamc/plazma/command/PlazmaCommand.java
@@ -0,0 +1,137 @@
+package org.plazmamc.plazma.command;
+
+import io.papermc.paper.command.CommandUtil;
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.Util;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionDefault;
+import org.bukkit.plugin.PluginManager;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.plazmamc.plazma.command.subcommands.ReloadCommand;
+import org.plazmamc.plazma.command.subcommands.VersionCommand;
+
+import java.util.*;
+import java.util.stream.Collectors;
+
+import static net.kyori.adventure.text.Component.text;
+import static net.kyori.adventure.text.format.NamedTextColor.RED;
+
+@DefaultQualifier(NonNull.class)
+public final class PlazmaCommand extends Command {
+    static final String BASE_PERM = "bukkit.command.plazma.";
+    // subcommand label -> subcommand
+    private static final Map<String, PlazmaSubcommand> SUBCOMMANDS = Util.make(() -> {
+        final Map<Set<String>, PlazmaSubcommand> commands = new HashMap<>();
+
+        commands.put(Set.of("reload"), new ReloadCommand());
+        commands.put(Set.of("version"), new VersionCommand());
+
+        return commands.entrySet().stream()
+                .flatMap(entry -> entry.getKey().stream().map(s -> Map.entry(s, entry.getValue())))
+                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
+    });
+    private static final Set<String> COMPLETABLE_SUBCOMMANDS = SUBCOMMANDS.entrySet().stream().filter(entry -> entry.getValue().tabCompletes()).map(Map.Entry::getKey).collect(Collectors.toSet());
+    // alias -> subcommand label
+    private static final Map<String, String> ALIASES = Util.make(() -> {
+        final Map<String, Set<String>> aliases = new HashMap<>();
+
+        aliases.put("version", Set.of("ver"));
+
+        return aliases.entrySet().stream()
+                .flatMap(entry -> entry.getValue().stream().map(s -> Map.entry(s, entry.getKey())))
+                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
+    });
+
+    public PlazmaCommand(final String name) {
+        super(name);
+        this.description = "Plazma related commands";
+        this.usageMessage = "/plazma [" + String.join(" | ", SUBCOMMANDS.keySet()) + "]";
+        final List<String> permissions = new ArrayList<>();
+        permissions.add("bukkit.command.plazma");
+        permissions.addAll(SUBCOMMANDS.keySet().stream().map(s -> BASE_PERM + s).toList());
+        this.setPermission(String.join(";", permissions));
+        final PluginManager pluginManager = Bukkit.getServer().getPluginManager();
+        for (final String perm : permissions) {
+            pluginManager.addPermission(new Permission(perm, PermissionDefault.OP));
+        }
+    }
+
+    private static boolean testPermission(final CommandSender sender, final String permission) {
+        if (sender.hasPermission(BASE_PERM + permission) || sender.hasPermission("bukkit.command.plazma")) {
+            return true;
+        }
+        sender.sendMessage(Bukkit.permissionMessage());
+        return false;
+    }
+
+    @Override
+    public List<String> tabComplete(
+            final CommandSender sender,
+            final String alias,
+            final String[] args,
+            final @Nullable Location location
+    ) throws IllegalArgumentException {
+        if (args.length <= 1) {
+            return CommandUtil.getListMatchingLast(sender, args, COMPLETABLE_SUBCOMMANDS);
+        }
+
+        final @Nullable Pair<String, PlazmaSubcommand> subCommand = resolveCommand(args[0]);
+        if (subCommand != null) {
+            return subCommand.second().tabComplete(sender, subCommand.first(), Arrays.copyOfRange(args, 1, args.length));
+        }
+
+        return Collections.emptyList();
+    }
+
+    @Override
+    public boolean execute(
+            final CommandSender sender,
+            final String commandLabel,
+            final String[] args
+    ) {
+        if (!testPermission(sender)) {
+            return true;
+        }
+
+        if (args.length == 0) {
+            sender.sendMessage(text("Usage: " + this.usageMessage, RED));
+            return false;
+        }
+        final @Nullable Pair<String, PlazmaSubcommand> subCommand = resolveCommand(args[0]);
+
+        if (subCommand == null) {
+            sender.sendMessage(text("Usage: " + this.usageMessage, RED));
+            return false;
+        }
+
+        if (!testPermission(sender, subCommand.first())) {
+            return true;
+        }
+        final String[] choppedArgs = Arrays.copyOfRange(args, 1, args.length);
+        return subCommand.second().execute(sender, subCommand.first(), choppedArgs);
+    }
+
+    private static @Nullable Pair<String, PlazmaSubcommand> resolveCommand(String label) {
+        label = label.toLowerCase(Locale.ROOT);
+        @Nullable PlazmaSubcommand subCommand = SUBCOMMANDS.get(label);
+        if (subCommand == null) {
+            final @Nullable String command = ALIASES.get(label);
+            if (command != null) {
+                label = command;
+                subCommand = SUBCOMMANDS.get(command);
+            }
+        }
+
+        if (subCommand != null) {
+            return Pair.of(label, subCommand);
+        }
+
+        return null;
+    }
+}
diff --git a/org/plazmamc/plazma/command/PlazmaCommands.java b/org/plazmamc/plazma/command/PlazmaCommands.java
new file mode 100644
index 0000000000000000000000000000000000000000..3828ca3a05bbc0218ecc5fd6c17e266975c16eb7
--- /dev/null
+++ b/org/plazmamc/plazma/command/PlazmaCommands.java
@@ -0,0 +1,52 @@
+package org.plazmamc.plazma.command;
+
+import com.mojang.brigadier.tree.LiteralCommandNode;
+import io.papermc.paper.command.MSPTCommand;
+import io.papermc.paper.command.PaperPluginsCommand;
+import io.papermc.paper.command.PaperVersionCommand;
+import io.papermc.paper.command.brigadier.CommandRegistrationFlag;
+import io.papermc.paper.command.brigadier.CommandSourceStack;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.command.Command;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+@DefaultQualifier(NonNull.class)
+public final class PlazmaCommands {
+
+    private PlazmaCommands() {
+    }
+
+    private static final Map<String, Command> COMMANDS = new HashMap<>();
+
+    public static void registerCommands(final MinecraftServer server) {
+        COMMANDS.put("plazma", new PlazmaCommand("plazma"));
+
+        COMMANDS.forEach((s, command) -> {
+            server.server.getCommandMap().register(s, "Plazma", command);
+        });
+    }
+
+    public static void registerCommands() {
+        // Paper commands go here
+        registerInternalCommand(PaperVersionCommand.create(), "bukkit", PaperVersionCommand.DESCRIPTION, List.of("ver", "about"), Set.of());
+        registerInternalCommand(PaperPluginsCommand.create(), "bukkit", PaperPluginsCommand.DESCRIPTION, List.of("pl"), Set.of());
+    }
+
+    private static void registerInternalCommand(final LiteralCommandNode<CommandSourceStack> node, final String namespace, final String description, final List<String> aliases, final Set<CommandRegistrationFlag> flags) {
+        io.papermc.paper.command.brigadier.PaperCommands.INSTANCE.registerWithFlagsInternal(
+            null,
+            namespace,
+            "Plazma",
+            node,
+            description,
+            aliases,
+            flags
+        );
+    }
+}
diff --git a/org/plazmamc/plazma/command/PlazmaSubcommand.java b/org/plazmamc/plazma/command/PlazmaSubcommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..3c8db7ead82f86fc50fb24b7c92a7c86065f34c1
--- /dev/null
+++ b/org/plazmamc/plazma/command/PlazmaSubcommand.java
@@ -0,0 +1,21 @@
+package org.plazmamc.plazma.command;
+
+import org.bukkit.command.CommandSender;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+import java.util.Collections;
+import java.util.List;
+
+@DefaultQualifier(NonNull.class)
+public interface PlazmaSubcommand {
+    boolean execute(CommandSender sender, String subCommand, String[] args);
+
+    default List<String> tabComplete(final CommandSender sender, final String subCommand, final String[] args) {
+        return Collections.emptyList();
+    }
+
+    default boolean tabCompletes() {
+        return true;
+    }
+}
diff --git a/org/plazmamc/plazma/command/subcommands/ReloadCommand.java b/org/plazmamc/plazma/command/subcommands/ReloadCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..d61d32dc33743894452c50a351f618ea1a3c1540
--- /dev/null
+++ b/org/plazmamc/plazma/command/subcommands/ReloadCommand.java
@@ -0,0 +1,33 @@
+package org.plazmamc.plazma.command.subcommands;
+
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.CraftServer;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.plazmamc.plazma.command.PlazmaSubcommand;
+
+import static net.kyori.adventure.text.Component.text;
+import static net.kyori.adventure.text.format.NamedTextColor.GREEN;
+import static net.kyori.adventure.text.format.NamedTextColor.RED;
+
+@DefaultQualifier(NonNull.class)
+public final class ReloadCommand implements PlazmaSubcommand {
+    @Override
+    public boolean execute(final CommandSender sender, final String subCommand, final String[] args) {
+        this.doReload(sender);
+        return true;
+    }
+
+    private void doReload(final CommandSender sender) {
+        Command.broadcastCommandMessage(sender, text("Please note that this command is not supported and may cause issues.", RED));
+        Command.broadcastCommandMessage(sender, text("If you encounter any issues please use the /stop command to restart your server.", RED));
+
+        MinecraftServer server = ((CraftServer) sender.getServer()).getServer();
+        server.plazmaConfigurations.reloadConfigs(server);
+        server.server.reloadCount++;
+
+        Command.broadcastCommandMessage(sender, text("Plazma config reload complete.", GREEN));
+    }
+}
diff --git a/org/plazmamc/plazma/command/subcommands/VersionCommand.java b/org/plazmamc/plazma/command/subcommands/VersionCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..6855f1fb0adb361587a996bbbd2980c1c7824498
--- /dev/null
+++ b/org/plazmamc/plazma/command/subcommands/VersionCommand.java
@@ -0,0 +1,21 @@
+package org.plazmamc.plazma.command.subcommands;
+
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.plazmamc.plazma.command.PlazmaSubcommand;
+
+@DefaultQualifier(NonNull.class)
+public final class VersionCommand implements PlazmaSubcommand {
+    @Override
+    public boolean execute(final CommandSender sender, final String subCommand, final String[] args) {
+        final @Nullable Command redirect = MinecraftServer.getServer().server.getCommandMap().getCommand("version");
+        if (redirect != null) {
+            redirect.execute(sender, "plazma", new String[0]);
+        }
+        return true;
+    }
+}
