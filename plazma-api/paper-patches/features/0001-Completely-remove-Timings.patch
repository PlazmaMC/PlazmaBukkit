From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: AlphaKR93 <dev@alpha93.kr>
Date: Sun, 23 Feb 2025 19:51:41 +0900
Subject: [PATCH] Completely remove Timings


diff --git a/src/main/java/co/aikar/timings/FullServerTickHandler.java b/src/main/java/co/aikar/timings/FullServerTickHandler.java
deleted file mode 100644
index 73b125979e2f2dfd13cbf689a90b29cc68a36e09..0000000000000000000000000000000000000000
--- a/src/main/java/co/aikar/timings/FullServerTickHandler.java
+++ /dev/null
@@ -1,89 +0,0 @@
-package co.aikar.timings;
-
-import static co.aikar.timings.TimingsManager.*;
-
-import org.bukkit.Bukkit;
-import org.jetbrains.annotations.NotNull;
-
-/**
- * @deprecated Timings will be removed in the future
- */
-@Deprecated(forRemoval = true)
-public class FullServerTickHandler extends TimingHandler {
-    private static final TimingIdentifier IDENTITY = new TimingIdentifier("Minecraft", "Full Server Tick", null);
-    final TimingData minuteData;
-    double avgFreeMemory = -1D;
-    double avgUsedMemory = -1D;
-    FullServerTickHandler() {
-        super(IDENTITY);
-        minuteData = new TimingData(id);
-
-        TIMING_MAP.put(IDENTITY, this);
-    }
-
-    @NotNull
-    @Override
-    public Timing startTiming() {
-        if (TimingsManager.needsFullReset) {
-            TimingsManager.resetTimings();
-        } else if (TimingsManager.needsRecheckEnabled) {
-            TimingsManager.recheckEnabled();
-        }
-        return super.startTiming();
-    }
-
-    @Override
-    public void stopTiming() {
-        super.stopTiming();
-        if (!isEnabled()) {
-            return;
-        }
-        if (TimingHistory.timedTicks % 20 == 0) {
-            final Runtime runtime = Runtime.getRuntime();
-            double usedMemory = runtime.totalMemory() - runtime.freeMemory();
-            double freeMemory = runtime.maxMemory() - usedMemory;
-            if (this.avgFreeMemory == -1) {
-                this.avgFreeMemory = freeMemory;
-            } else {
-                this.avgFreeMemory = (this.avgFreeMemory * (59 / 60D)) + (freeMemory * (1 / 60D));
-            }
-
-            if (this.avgUsedMemory == -1) {
-                this.avgUsedMemory = usedMemory;
-            } else {
-                this.avgUsedMemory = (this.avgUsedMemory * (59 / 60D)) + (usedMemory * (1 / 60D));
-            }
-        }
-
-        long start = System.nanoTime();
-        TimingsManager.tick();
-        long diff = System.nanoTime() - start;
-        TIMINGS_TICK.addDiff(diff, null);
-        // addDiff for TIMINGS_TICK incremented this, bring it back down to 1 per tick.
-        record.setCurTickCount(record.getCurTickCount()-1);
-
-        minuteData.setCurTickTotal(record.getCurTickTotal());
-        minuteData.setCurTickCount(1);
-
-        boolean violated = isViolated();
-        minuteData.processTick(violated);
-        TIMINGS_TICK.processTick(violated);
-        processTick(violated);
-
-
-        if (TimingHistory.timedTicks % 1200 == 0) {
-            MINUTE_REPORTS.add(new TimingHistory.MinuteReport());
-            TimingHistory.resetTicks(false);
-            minuteData.reset();
-        }
-        if (TimingHistory.timedTicks % Timings.getHistoryInterval() == 0) {
-            TimingsManager.HISTORY.add(new TimingHistory());
-            TimingsManager.resetTimings();
-        }
-        //Bukkit.getUnsafe().reportTimings();
-    }
-
-    boolean isViolated() {
-        return record.getCurTickTotal() > 50000000;
-    }
-}
diff --git a/src/main/java/co/aikar/timings/NullTimingHandler.java b/src/main/java/co/aikar/timings/NullTimingHandler.java
deleted file mode 100644
index 42e7e712403676171d34d5f2be27e48e7a071ebd..0000000000000000000000000000000000000000
--- a/src/main/java/co/aikar/timings/NullTimingHandler.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * This file is licensed under the MIT License (MIT).
- *
- * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package co.aikar.timings;
-
-import org.jetbrains.annotations.NotNull;
-import org.jetbrains.annotations.Nullable;
-
-/**
- * @deprecated Timings will be removed in the future
- */
-@Deprecated(forRemoval = true)
-public final class NullTimingHandler implements Timing {
-    public static final Timing NULL = new NullTimingHandler();
-    @NotNull
-    @Override
-    public Timing startTiming() {
-        return this;
-    }
-
-    @Override
-    public void stopTiming() {
-
-    }
-
-    @NotNull
-    @Override
-    public Timing startTimingIfSync() {
-        return this;
-    }
-
-    @Override
-    public void stopTimingIfSync() {
-
-    }
-
-    @Override
-    public void abort() {
-
-    }
-
-    @Nullable
-    @Override
-    public TimingHandler getTimingHandler() {
-        return null;
-    }
-
-    @Override
-    public void close() {
-
-    }
-}
diff --git a/src/main/java/co/aikar/timings/TimedEventExecutor.java b/src/main/java/co/aikar/timings/TimedEventExecutor.java
deleted file mode 100644
index c178d77bd23a484043f50e46ccd603734f7b6059..0000000000000000000000000000000000000000
--- a/src/main/java/co/aikar/timings/TimedEventExecutor.java
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * This file is licensed under the MIT License (MIT).
- *
- * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package co.aikar.timings;
-
-import org.bukkit.Bukkit;
-import org.bukkit.event.Event;
-import org.bukkit.event.EventException;
-import org.bukkit.event.Listener;
-import org.bukkit.plugin.EventExecutor;
-import org.bukkit.plugin.Plugin;
-
-import java.lang.reflect.Method;
-import org.jetbrains.annotations.NotNull;
-import org.jetbrains.annotations.Nullable;
-
-/**
- * @deprecated Timings will be removed in the future
- */
-@Deprecated(forRemoval = true)
-public class TimedEventExecutor implements EventExecutor {
-
-    private final EventExecutor executor;
-    private final Timing timings;
-
-    /**
-     * Wraps an event executor and associates a timing handler to it.
-     *
-     * @param executor Executor to wrap
-     * @param plugin Owning plugin
-     * @param method EventHandler method
-     * @param eventClass Owning class
-     */
-    public TimedEventExecutor(@NotNull EventExecutor executor, @NotNull Plugin plugin, @Nullable Method method, @NotNull Class<? extends Event> eventClass) {
-        this.executor = executor;
-        String id;
-
-        if (method == null) {
-            if (executor.getClass().getEnclosingClass() != null) { // Oh Skript, how we love you
-                method = executor.getClass().getEnclosingMethod();
-            }
-        }
-
-        if (method != null) {
-            id = method.getDeclaringClass().getName();
-        } else {
-            id = executor.getClass().getName();
-        }
-
-
-        final String eventName = eventClass.getSimpleName();
-        boolean verbose = "BlockPhysicsEvent".equals(eventName);
-        this.timings = Timings.ofSafe(plugin, (verbose ? "## " : "") +
-            "Event: " + id + " (" + eventName + ")");
-    }
-
-    @Override
-    public void execute(@NotNull Listener listener, @NotNull Event event) throws EventException {
-        if (event.isAsynchronous() || !Timings.timingsEnabled || !Bukkit.isPrimaryThread()) {
-            executor.execute(listener, event);
-            return;
-        }
-        //try (Timing ignored = timings.startTiming()){ // Purpur - Remove Timings
-            executor.execute(listener, event);
-        //} // Purpur - Remove Timings
-    }
-
-    @Override
-    @NotNull
-    public String toString() {
-        return "TimedEventExecutor['" + this.executor.toString() + "']";
-    }
-}
diff --git a/src/main/java/co/aikar/timings/Timing.java b/src/main/java/co/aikar/timings/Timing.java
index acd06662bf1da1f12f73e2e85c0fd1b10f3b8b93..15e41945ba5acee7956758899fd6f1c0229053e4 100644
--- a/src/main/java/co/aikar/timings/Timing.java
+++ b/src/main/java/co/aikar/timings/Timing.java
@@ -33,22 +33,28 @@ import org.jetbrains.annotations.Nullable;
  */
 @Deprecated(forRemoval = true)
 public interface Timing extends AutoCloseable {
+
     /**
      * Starts timing the execution until {@link #stopTiming()} is called.
      *
      * @return Timing
      */
-    @NotNull
+    @Deprecated(forRemoval = true) // Plazma - Completely remove timings
     @io.papermc.paper.annotation.DoNotUse // Purpur - Remove Timings
-    Timing startTiming();
+    default Timing startTiming() { // Plazma - Completely remove timings
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
+    } // Plazma - Completely remove timings
 
     /**
      * <p>Stops timing and records the data. Propagates the data up to group handlers.</p>
      *
      * Will automatically be called when this Timing is used with try-with-resources
      */
+    @Deprecated(forRemoval = true) // Plazma - Completely remove timings
     @io.papermc.paper.annotation.DoNotUse // Purpur - Remove Timings
-    void stopTiming();
+    default void stopTiming() { // Plazma - Completely remove timings
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
+    } // Plazma - Completely remove timings
 
     /**
      * Starts timing the execution until {@link #stopTiming()} is called.
@@ -57,9 +63,11 @@ public interface Timing extends AutoCloseable {
      *
      * @return Timing
      */
-    @NotNull
+    @Deprecated(forRemoval = true) // Plazma - Completely remove timings
     @io.papermc.paper.annotation.DoNotUse // Purpur - Remove Timings
-    Timing startTimingIfSync();
+    default Timing startTimingIfSync() { // Plazma - Completely remove timings
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
+    } // Plazma - Completely remove timings
 
     /**
      * <p>Stops timing and records the data. Propagates the data up to group handlers.</p>
@@ -68,25 +76,34 @@ public interface Timing extends AutoCloseable {
      *
      * But only if we are on the primary thread.
      */
+    @Deprecated(forRemoval = true) // Plazma - Completely remove timings
     @io.papermc.paper.annotation.DoNotUse // Purpur - Remove Timings
-    void stopTimingIfSync();
+    default void stopTimingIfSync() { // Plazma - Completely remove timings
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
+    } // Plazma - Completely remove timings
 
     /**
      * @deprecated Doesn't do anything - Removed
      */
-    @Deprecated
+    @Deprecated(forRemoval = true) // Plazma - Completely remove timings
     @io.papermc.paper.annotation.DoNotUse // Purpur - Remove Timings
-    void abort();
+    default void abort() { // Plazma - Completely remove timings
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
+    } // Plazma - Completely remove timings
 
     /**
      * Used internally to get the actual backing Handler in the case of delegated Handlers
      *
      * @return TimingHandler
      */
-    @Nullable
-    TimingHandler getTimingHandler();
+    //@Nullable // Plazma - Completely remove timings
+    //TimingHandler getTimingHandler(); // Plazma - Completely remove timings
 
     @Override
+    @Deprecated(forRemoval = true) // Plazma - Completely remove timings
     @io.papermc.paper.annotation.DoNotUse // Purpur - Remove Timings
-    void close();
+    default void close() { // Plazma - Completely remove timings
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
+    } // Plazma - Completely remove timings
+
 }
diff --git a/src/main/java/co/aikar/timings/TimingData.java b/src/main/java/co/aikar/timings/TimingData.java
deleted file mode 100644
index a5d13a1e44edb861f45c83a9b4309fbf799d407d..0000000000000000000000000000000000000000
--- a/src/main/java/co/aikar/timings/TimingData.java
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * This file is licensed under the MIT License (MIT).
- *
- * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package co.aikar.timings;
-
-import java.util.List;
-import org.jetbrains.annotations.NotNull;
-
-import static co.aikar.util.JSONUtil.toArray;
-
-/**
- * <p>Lightweight object for tracking timing data</p>
- *
- * This is broken out to reduce memory usage
- */
-class TimingData {
-    private final int id;
-    private int count = 0;
-    private int lagCount = 0;
-    private long totalTime = 0;
-    private long lagTotalTime = 0;
-    private int curTickCount = 0;
-    private long curTickTotal = 0;
-
-    TimingData(int id) {
-        this.id = id;
-    }
-
-    private TimingData(TimingData data) {
-        this.id = data.id;
-        this.totalTime = data.totalTime;
-        this.lagTotalTime = data.lagTotalTime;
-        this.count = data.count;
-        this.lagCount = data.lagCount;
-    }
-
-    void add(long diff) {
-        ++curTickCount;
-        curTickTotal += diff;
-    }
-
-    void processTick(boolean violated) {
-        totalTime += curTickTotal;
-        count += curTickCount;
-        if (violated) {
-            lagTotalTime += curTickTotal;
-            lagCount += curTickCount;
-        }
-        curTickTotal = 0;
-        curTickCount = 0;
-    }
-
-    void reset() {
-        count = 0;
-        lagCount = 0;
-        curTickTotal = 0;
-        curTickCount = 0;
-        totalTime = 0;
-        lagTotalTime = 0;
-    }
-
-    protected TimingData clone() {
-        return new TimingData(this);
-    }
-
-    @NotNull
-    List<Object> export() {
-        List<Object> list = toArray(
-            id,
-            count,
-            totalTime);
-        if (lagCount > 0) {
-            list.add(lagCount);
-            list.add(lagTotalTime);
-        }
-        return list;
-    }
-
-    boolean hasData() {
-        return count > 0;
-    }
-
-    long getTotalTime() {
-        return totalTime;
-    }
-
-    int getCurTickCount() {
-        return curTickCount;
-    }
-
-    void setCurTickCount(int curTickCount) {
-        this.curTickCount = curTickCount;
-    }
-
-    long getCurTickTotal() {
-        return curTickTotal;
-    }
-
-    void setCurTickTotal(long curTickTotal) {
-        this.curTickTotal = curTickTotal;
-    }
-}
diff --git a/src/main/java/co/aikar/timings/TimingHandler.java b/src/main/java/co/aikar/timings/TimingHandler.java
deleted file mode 100644
index 199789d56d22fcb1b77ebd56805cc28aa5a5ab0a..0000000000000000000000000000000000000000
--- a/src/main/java/co/aikar/timings/TimingHandler.java
+++ /dev/null
@@ -1,226 +0,0 @@
-/*
- * This file is licensed under the MIT License (MIT).
- *
- * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package co.aikar.timings;
-
-import co.aikar.util.LoadingIntMap;
-import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
-
-import java.util.ArrayDeque;
-import java.util.Deque;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import org.bukkit.Bukkit;
-import org.jetbrains.annotations.NotNull;
-import org.jetbrains.annotations.Nullable;
-
-class TimingHandler implements Timing {
-
-    private static AtomicInteger idPool = new AtomicInteger(1);
-    private static Deque<TimingHandler> TIMING_STACK = new ArrayDeque<>();
-    final int id = idPool.getAndIncrement();
-
-    final TimingIdentifier identifier;
-    private final boolean verbose;
-
-    private final Int2ObjectOpenHashMap<TimingData> children = new LoadingIntMap<>(TimingData::new);
-
-    final TimingData record;
-    private TimingHandler startParent;
-    private final TimingHandler groupHandler;
-
-    private long start = 0;
-    private int timingDepth = 0;
-    private boolean added;
-    private boolean timed;
-    private boolean enabled;
-
-    TimingHandler(@NotNull TimingIdentifier id) {
-        this.identifier = id;
-        this.verbose = id.name.startsWith("##");
-        this.record = new TimingData(this.id);
-        this.groupHandler = id.groupHandler;
-
-        TimingIdentifier.getGroup(id.group).handlers.add(this);
-        checkEnabled();
-    }
-
-    final void checkEnabled() {
-        enabled = Timings.timingsEnabled && (!verbose || Timings.verboseEnabled);
-    }
-
-    void processTick(boolean violated) {
-        if (timingDepth != 0 || record.getCurTickCount() == 0) {
-            timingDepth = 0;
-            start = 0;
-            return;
-        }
-
-        record.processTick(violated);
-        for (TimingData handler : children.values()) {
-            handler.processTick(violated);
-        }
-    }
-
-    @NotNull
-    @Override
-    public Timing startTimingIfSync() {
-        startTiming();
-        return this;
-    }
-
-    @Override
-    public void stopTimingIfSync() {
-        stopTiming();
-    }
-
-    @NotNull
-    public Timing startTiming() {
-        if (!enabled || !Bukkit.isPrimaryThread()) {
-            return this;
-        }
-        if (++timingDepth == 1) {
-            startParent = TIMING_STACK.peekLast();
-            start = System.nanoTime();
-        }
-        TIMING_STACK.addLast(this);
-        return this;
-    }
-
-    public void stopTiming() {
-        if (!enabled || timingDepth <= 0 || start == 0 || !Bukkit.isPrimaryThread()) {
-            return;
-        }
-
-        popTimingStack();
-        if (--timingDepth == 0) {
-            addDiff(System.nanoTime() - start, startParent);
-            startParent = null;
-            start = 0;
-        }
-    }
-
-    private void popTimingStack() {
-        TimingHandler last;
-        while ((last = TIMING_STACK.removeLast()) != this) {
-            last.timingDepth = 0;
-            if ("Minecraft".equalsIgnoreCase(last.identifier.group)) {
-                Logger.getGlobal().log(Level.SEVERE, "TIMING_STACK_CORRUPTION - Look above this for any errors and report this to Paper unless it has a plugin in the stack trace (" + last.identifier + " did not stopTiming)");
-            } else {
-                Logger.getGlobal().log(Level.SEVERE, "TIMING_STACK_CORRUPTION - Report this to the plugin " + last.identifier.group + " (Look for errors above this in the logs) (" + last.identifier + " did not stopTiming)", new Throwable());
-            }
-
-            boolean found = TIMING_STACK.contains(this);
-            if (!found) {
-                // We aren't even in the stack... Don't pop everything
-                TIMING_STACK.addLast(last);
-                break;
-            }
-        }
-    }
-
-    @Override
-    public final void abort() {
-
-    }
-
-    void addDiff(long diff, @Nullable TimingHandler parent) {
-        if (parent != null) {
-            parent.children.get(id).add(diff);
-        }
-
-        record.add(diff);
-        if (!added) {
-            added = true;
-            timed = true;
-            TimingsManager.HANDLERS.add(this);
-        }
-        if (groupHandler != null) {
-            groupHandler.addDiff(diff, parent);
-            groupHandler.children.get(id).add(diff);
-        }
-    }
-
-    /**
-     * Reset this timer, setting all values to zero.
-     */
-    void reset(boolean full) {
-        record.reset();
-        if (full) {
-            timed = false;
-        }
-        start = 0;
-        timingDepth = 0;
-        added = false;
-        children.clear();
-        checkEnabled();
-    }
-
-    @NotNull
-    @Override
-    public TimingHandler getTimingHandler() {
-        return this;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        return (this == o);
-    }
-
-    @Override
-    public int hashCode() {
-        return id;
-    }
-
-    /**
-     * This is simply for the Closeable interface so it can be used with try-with-resources ()
-     */
-    @Override
-    public void close() {
-        stopTimingIfSync();
-    }
-
-    public boolean isSpecial() {
-        return this == TimingsManager.FULL_SERVER_TICK || this == TimingsManager.TIMINGS_TICK;
-    }
-
-    boolean isTimed() {
-        return timed;
-    }
-
-    public boolean isEnabled() {
-        return enabled;
-    }
-
-    @NotNull
-    TimingData[] cloneChildren() {
-        final TimingData[] clonedChildren = new TimingData[children.size()];
-        int i = 0;
-        for (TimingData child : children.values()) {
-            clonedChildren[i++] = child.clone();
-        }
-        return clonedChildren;
-    }
-}
diff --git a/src/main/java/co/aikar/timings/TimingHistory.java b/src/main/java/co/aikar/timings/TimingHistory.java
deleted file mode 100644
index 6f6eb1a2e6c8d49014a7ae44540ee282bae5200e..0000000000000000000000000000000000000000
--- a/src/main/java/co/aikar/timings/TimingHistory.java
+++ /dev/null
@@ -1,357 +0,0 @@
-/*
- * This file is licensed under the MIT License (MIT).
- *
- * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package co.aikar.timings;
-
-import co.aikar.timings.TimingHistory.RegionData.RegionId;
-import com.google.common.base.Function;
-import com.google.common.collect.Sets;
-import org.bukkit.Bukkit;
-import org.bukkit.Chunk;
-import org.bukkit.Material;
-import org.bukkit.World;
-import org.bukkit.block.BlockState;
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.EntityType;
-import org.bukkit.entity.Player;
-import co.aikar.util.LoadingMap;
-import co.aikar.util.MRUMapCache;
-
-import java.lang.management.ManagementFactory;
-import java.util.Collection;
-import java.util.EnumMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import org.jetbrains.annotations.NotNull;
-import org.jetbrains.annotations.Nullable;
-
-import static co.aikar.timings.TimingsManager.FULL_SERVER_TICK;
-import static co.aikar.timings.TimingsManager.MINUTE_REPORTS;
-import static co.aikar.util.JSONUtil.*;
-
-/**
- * Internal.
- *
- * @deprecated Timings will be removed in the future
- */
-@Deprecated(forRemoval = true)
-@SuppressWarnings({"deprecation", "SuppressionAnnotation", "Convert2Lambda", "Anonymous2MethodRef"})
-public class TimingHistory {
-    public static long lastMinuteTime;
-    public static long timedTicks;
-    public static long playerTicks;
-    public static long entityTicks;
-    public static long tileEntityTicks;
-    public static long activatedEntityTicks;
-    private static int worldIdPool = 1;
-    static Map<String, Integer> worldMap = LoadingMap.newHashMap(new Function<String, Integer>() {
-        @NotNull
-        @Override
-        public Integer apply(@Nullable String input) {
-            return worldIdPool++;
-        }
-    });
-    private final long endTime;
-    private final long startTime;
-    private final long totalTicks;
-    private final long totalTime; // Represents all time spent running the server this history
-    private final MinuteReport[] minuteReports;
-
-    private final TimingHistoryEntry[] entries;
-    final Set<Material> tileEntityTypeSet = Sets.newHashSet();
-    final Set<EntityType> entityTypeSet = Sets.newHashSet();
-    private final Map<Object, Object> worlds;
-
-    TimingHistory() {
-        this.endTime = System.currentTimeMillis() / 1000;
-        this.startTime = TimingsManager.historyStart / 1000;
-        if (timedTicks % 1200 != 0 || MINUTE_REPORTS.isEmpty()) {
-            this.minuteReports = MINUTE_REPORTS.toArray(new MinuteReport[MINUTE_REPORTS.size() + 1]);
-            this.minuteReports[this.minuteReports.length - 1] = new MinuteReport();
-        } else {
-            this.minuteReports = MINUTE_REPORTS.toArray(new MinuteReport[MINUTE_REPORTS.size()]);
-        }
-        long ticks = 0;
-        for (MinuteReport mp : this.minuteReports) {
-            ticks += mp.ticksRecord.timed;
-        }
-        this.totalTicks = ticks;
-        this.totalTime = FULL_SERVER_TICK.record.getTotalTime();
-        this.entries = new TimingHistoryEntry[TimingsManager.HANDLERS.size()];
-
-        int i = 0;
-        for (TimingHandler handler : TimingsManager.HANDLERS) {
-            entries[i++] = new TimingHistoryEntry(handler);
-        }
-
-        // Information about all loaded chunks/entities
-        //noinspection unchecked
-        this.worlds = toObjectMapper(Bukkit.getWorlds(), new Function<World, JSONPair>() {
-            @NotNull
-            @Override
-            public JSONPair apply(World world) {
-                Map<RegionId, RegionData> regions = LoadingMap.newHashMap(RegionData.LOADER);
-
-                for (Chunk chunk : world.getLoadedChunks()) {
-                    RegionData data = regions.get(new RegionId(chunk.getX(), chunk.getZ()));
-
-                    for (Entity entity : chunk.getEntities()) {
-                        if (entity == null) {
-                            Bukkit.getLogger().warning("Null entity detected in chunk at position x: " + chunk.getX() + ", z: " + chunk.getZ());
-                            continue;
-                        }
-
-                        data.entityCounts.get(entity.getType()).increment();
-                    }
-
-                    for (BlockState tileEntity : chunk.getTileEntities(false)) {
-                        if (tileEntity == null) {
-                            Bukkit.getLogger().warning("Null tileentity detected in chunk at position x: " + chunk.getX() + ", z: " + chunk.getZ());
-                            continue;
-                        }
-
-                        data.tileEntityCounts.get(tileEntity.getBlock().getType()).increment();
-                    }
-                }
-                return pair(
-                    worldMap.get(world.getName()),
-                    toArrayMapper(regions.values(),new Function<RegionData, Object>() {
-                        @NotNull
-                        @Override
-                        public Object apply(RegionData input) {
-                            return toArray(
-                                input.regionId.x,
-                                input.regionId.z,
-                                toObjectMapper(input.entityCounts.entrySet(),
-                                    new Function<Map.Entry<EntityType, Counter>, JSONPair>() {
-                                        @NotNull
-                                        @Override
-                                        public JSONPair apply(Map.Entry<EntityType, Counter> entry) {
-                                            entityTypeSet.add(entry.getKey());
-                                            return pair(
-                                                    String.valueOf(entry.getKey().ordinal()),
-                                                    entry.getValue().count()
-                                            );
-                                        }
-                                    }
-                                ),
-                                toObjectMapper(
-                                    input.tileEntityCounts.entrySet(),
-                                    entry -> {
-                                        tileEntityTypeSet.add(entry.getKey());
-                                        return pair(
-                                            String.valueOf(entry.getKey().ordinal()),
-                                            entry.getValue().count()
-                                        );
-                                    }
-                                )
-                            );
-                        }
-                    })
-                );
-            }
-        });
-    }
-    static class RegionData {
-        final RegionId regionId;
-        @SuppressWarnings("Guava")
-        static Function<RegionId, RegionData> LOADER = new Function<RegionId, RegionData>() {
-            @NotNull
-            @Override
-            public RegionData apply(@NotNull RegionId id) {
-                return new RegionData(id);
-            }
-        };
-        RegionData(@NotNull RegionId id) {
-            this.regionId = id;
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (this == o) {
-                return true;
-            }
-            if (o == null || getClass() != o.getClass()) {
-                return false;
-            }
-
-            RegionData that = (RegionData) o;
-
-            return regionId.equals(that.regionId);
-
-        }
-
-        @Override
-        public int hashCode() {
-            return regionId.hashCode();
-        }
-
-        @SuppressWarnings("unchecked")
-        final Map<EntityType, Counter> entityCounts = MRUMapCache.of(LoadingMap.of(
-                new EnumMap<EntityType, Counter>(EntityType.class), k -> new Counter()
-        ));
-        @SuppressWarnings("unchecked")
-        final Map<Material, Counter> tileEntityCounts = MRUMapCache.of(LoadingMap.of(
-                new EnumMap<Material, Counter>(Material.class), k -> new Counter()
-        ));
-
-        static class RegionId {
-            final int x, z;
-            final long regionId;
-            RegionId(int x, int z) {
-                this.x = x >> 5 << 5;
-                this.z = z >> 5 << 5;
-                this.regionId = ((long) (this.x) << 32) + (this.z >> 5 << 5) - Integer.MIN_VALUE;
-            }
-
-            @Override
-            public boolean equals(Object o) {
-                if (this == o) return true;
-                if (o == null || getClass() != o.getClass()) return false;
-
-                RegionId regionId1 = (RegionId) o;
-
-                return regionId == regionId1.regionId;
-
-            }
-
-            @Override
-            public int hashCode() {
-                return (int) (regionId ^ (regionId >>> 32));
-            }
-        }
-    }
-    static void resetTicks(boolean fullReset) {
-        if (fullReset) {
-            // Non full is simply for 1 minute reports
-            timedTicks = 0;
-        }
-        lastMinuteTime = System.nanoTime();
-        playerTicks = 0;
-        tileEntityTicks = 0;
-        entityTicks = 0;
-        activatedEntityTicks = 0;
-    }
-
-    @NotNull
-    Object export() {
-        return createObject(
-            pair("s", startTime),
-            pair("e", endTime),
-            pair("tk", totalTicks),
-            pair("tm", totalTime),
-            pair("w", worlds),
-            pair("h", toArrayMapper(entries, new Function<TimingHistoryEntry, Object>() {
-                @Nullable
-                @Override
-                public Object apply(TimingHistoryEntry entry) {
-                    TimingData record = entry.data;
-                    if (!record.hasData()) {
-                        return null;
-                    }
-                    return entry.export();
-                }
-            })),
-            pair("mp", toArrayMapper(minuteReports, new Function<MinuteReport, Object>() {
-                @NotNull
-                @Override
-                public Object apply(MinuteReport input) {
-                    return input.export();
-                }
-            }))
-        );
-    }
-
-    static class MinuteReport {
-        final long time = System.currentTimeMillis() / 1000;
-
-        final TicksRecord ticksRecord = new TicksRecord();
-        final PingRecord pingRecord = new PingRecord();
-        final TimingData fst = TimingsManager.FULL_SERVER_TICK.minuteData.clone();
-        final double tps = 1E9 / ( System.nanoTime() - lastMinuteTime ) * ticksRecord.timed;
-        final double usedMemory = TimingsManager.FULL_SERVER_TICK.avgUsedMemory;
-        final double freeMemory = TimingsManager.FULL_SERVER_TICK.avgFreeMemory;
-        final double loadAvg = ManagementFactory.getOperatingSystemMXBean().getSystemLoadAverage();
-
-        @NotNull
-        List<Object> export() {
-            return toArray(
-                time,
-                Math.round(tps * 100D) / 100D,
-                Math.round(pingRecord.avg * 100D) / 100D,
-                fst.export(),
-                toArray(ticksRecord.timed,
-                    ticksRecord.player,
-                    ticksRecord.entity,
-                    ticksRecord.activatedEntity,
-                    ticksRecord.tileEntity
-                ),
-                usedMemory,
-                freeMemory,
-                loadAvg
-            );
-        }
-    }
-
-    private static class TicksRecord {
-        final long timed;
-        final long player;
-        final long entity;
-        final long tileEntity;
-        final long activatedEntity;
-
-        TicksRecord() {
-            timed = timedTicks - (TimingsManager.MINUTE_REPORTS.size() * 1200);
-            player = playerTicks;
-            entity = entityTicks;
-            tileEntity = tileEntityTicks;
-            activatedEntity = activatedEntityTicks;
-        }
-
-    }
-
-    private static class PingRecord {
-        final double avg;
-
-        PingRecord() {
-            final Collection<? extends Player> onlinePlayers = Bukkit.getOnlinePlayers();
-            int totalPing = 0;
-            for (Player player : onlinePlayers) {
-                totalPing += player.spigot().getPing();
-            }
-            avg = onlinePlayers.isEmpty() ? 0 : totalPing / onlinePlayers.size();
-        }
-    }
-
-
-    private static class Counter {
-        private int count = 0;
-        public int increment() {
-            return ++count;
-        }
-        public int count() {
-            return count;
-        }
-    }
-}
diff --git a/src/main/java/co/aikar/timings/TimingHistoryEntry.java b/src/main/java/co/aikar/timings/TimingHistoryEntry.java
deleted file mode 100644
index 86d5ac6bd0d7d0003688761aceb3f3343575319f..0000000000000000000000000000000000000000
--- a/src/main/java/co/aikar/timings/TimingHistoryEntry.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * This file is licensed under the MIT License (MIT).
- *
- * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package co.aikar.timings;
-
-import com.google.common.base.Function;
-
-import java.util.List;
-import org.jetbrains.annotations.NotNull;
-
-import static co.aikar.util.JSONUtil.toArrayMapper;
-
-class TimingHistoryEntry {
-    final TimingData data;
-    private final TimingData[] children;
-
-    TimingHistoryEntry(@NotNull TimingHandler handler) {
-        this.data = handler.record.clone();
-        children = handler.cloneChildren();
-    }
-
-    @NotNull
-    List<Object> export() {
-        List<Object> result = data.export();
-        if (children.length > 0) {
-            result.add(
-                toArrayMapper(children, new Function<TimingData, Object>() {
-                    @NotNull
-                    @Override
-                    public Object apply(TimingData child) {
-                        return child.export();
-                    }
-                })
-            );
-        }
-        return result;
-    }
-}
diff --git a/src/main/java/co/aikar/timings/TimingIdentifier.java b/src/main/java/co/aikar/timings/TimingIdentifier.java
deleted file mode 100644
index df142a89b8c43acb81eb383eac0ef048a1f49a6e..0000000000000000000000000000000000000000
--- a/src/main/java/co/aikar/timings/TimingIdentifier.java
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * This file is licensed under the MIT License (MIT).
- *
- * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package co.aikar.timings;
-
-import co.aikar.util.LoadingMap;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.atomic.AtomicInteger;
-import org.jetbrains.annotations.NotNull;
-import org.jetbrains.annotations.Nullable;
-
-/**
- * <p>Used as a basis for fast HashMap key comparisons for the Timing Map.</p>
- *
- * This class uses interned strings giving us the ability to do an identity check instead of equals() on the strings
- */
-final class TimingIdentifier {
-    /**
-     * Holds all groups. Autoloads on request for a group by name.
-     */
-    static final Map<String, TimingGroup> GROUP_MAP = LoadingMap.of(new ConcurrentHashMap<>(64, .5F), TimingGroup::new);
-    private static final TimingGroup DEFAULT_GROUP = getGroup("Minecraft");
-    final String group;
-    final String name;
-    final TimingHandler groupHandler;
-    private final int hashCode;
-
-    TimingIdentifier(@Nullable String group, @NotNull String name, @Nullable Timing groupHandler) {
-        this.group = group != null ? group: DEFAULT_GROUP.name;
-        this.name = name;
-        this.groupHandler = groupHandler != null ? groupHandler.getTimingHandler() : null;
-        this.hashCode = (31 * this.group.hashCode()) + this.name.hashCode();
-    }
-
-    @NotNull
-    static TimingGroup getGroup(@Nullable String groupName) {
-        if (groupName == null) {
-            //noinspection ConstantConditions
-            return DEFAULT_GROUP;
-        }
-
-        return GROUP_MAP.get(groupName);
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (o == null) {
-            return false;
-        }
-
-        TimingIdentifier that = (TimingIdentifier) o;
-        return Objects.equals(group, that.group) && Objects.equals(name, that.name);
-    }
-
-    @Override
-    public int hashCode() {
-        return hashCode;
-    }
-
-    @Override
-    public String toString() {
-        return "TimingIdentifier{id=" + group + ":" + name +'}';
-    }
-
-    static class TimingGroup {
-
-        private static AtomicInteger idPool = new AtomicInteger(1);
-        final int id = idPool.getAndIncrement();
-
-        final String name;
-        final List<TimingHandler> handlers = Collections.synchronizedList(new ArrayList<>(64));
-
-        private TimingGroup(String name) {
-            this.name = name;
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (this == o) return true;
-            if (o == null || getClass() != o.getClass()) return false;
-            TimingGroup that = (TimingGroup) o;
-            return id == that.id;
-        }
-
-        @Override
-        public int hashCode() {
-            return id;
-        }
-    }
-}
diff --git a/src/main/java/co/aikar/timings/Timings.java b/src/main/java/co/aikar/timings/Timings.java
index 627922fa5c65e9b77e79cd896c8c52889f5a0cc5..5c7e8953e2ea221546d0d61e7dd8a161434da003 100644
--- a/src/main/java/co/aikar/timings/Timings.java
+++ b/src/main/java/co/aikar/timings/Timings.java
@@ -40,6 +40,9 @@ import java.util.logging.Level;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
+import org.jetbrains.annotations.Contract; // Plazma - Completely remove timings
+import io.papermc.paper.annotation.DoNotUse; // Plazma - Completely remove timings
+
 /**
  * @deprecated Timings will be removed in the future
  */
@@ -47,15 +50,6 @@ import org.jetbrains.annotations.Nullable;
 @SuppressWarnings({"UnusedDeclaration", "WeakerAccess", "SameParameterValue"})
 public final class Timings {
 
-    final static List<CommandSender> requestingReport = Lists.newArrayList();
-    private static final int MAX_HISTORY_FRAMES = 12;
-    public static final Timing NULL_HANDLER = new NullTimingHandler();
-    static boolean timingsEnabled = false;
-    static boolean verboseEnabled = false;
-    private static int historyInterval = -1;
-    private static int historyLength = -1;
-    private static boolean warnedAboutDeprecationOnEnable;
-
     private Timings() {}
 
     /**
@@ -65,13 +59,10 @@ public final class Timings {
      * @param name   Name of Timing
      * @return Handler
      */
-    @NotNull
+    @Contract(value = "_, _ -> fail", pure = true) // Plazma - Completely remove timings
+    @Deprecated(forRemoval = true) @DoNotUse // Plazma - Completely remove timings
     public static Timing of(@NotNull Plugin plugin, @NotNull String name) {
-        Timing pluginHandler = null;
-        if (plugin != null) {
-            pluginHandler = ofSafe(plugin.getName(), "Combined Total", TimingsManager.PLUGIN_GROUP_HANDLER);
-        }
-        return of(plugin, name, pluginHandler);
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
     }
 
     /**
@@ -86,11 +77,10 @@ public final class Timings {
      * @param groupHandler Parent handler to mirror .start/stop calls to
      * @return Timing Handler
      */
-    @NotNull
+    @Contract(value = "_, _, _ -> fail", pure = true) // Plazma - Completely remove timings
+    @Deprecated(forRemoval = true) @DoNotUse // Plazma - Completely remove timings
     public static Timing of(@NotNull Plugin plugin, @NotNull String name, @Nullable Timing groupHandler) {
-        Preconditions.checkNotNull(plugin, "Plugin can not be null");
-        Bukkit.getLogger().warning(String.format("Plugin '%s' is creating timing '%s' - this is deprecated behavior, please report it to the authors: %s", plugin.getName(), name, String.join(", ", plugin.getDescription().getAuthors())));
-        return TimingsManager.getHandler(plugin.getName(), name, groupHandler);
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
     }
 
     /**
@@ -104,9 +94,10 @@ public final class Timings {
      * @param name   Name of Timing
      * @return Timing Handler
      */
-    @NotNull
+    @Contract(value = "_, _ -> fail", pure = true) // Plazma - Completely remove timings
+    @Deprecated(forRemoval = true) @DoNotUse // Plazma - Completely remove timings
     public static Timing ofStart(@NotNull Plugin plugin, @NotNull String name) {
-        return ofStart(plugin, name, null);
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
     }
 
     /**
@@ -121,11 +112,10 @@ public final class Timings {
      * @param groupHandler Parent handler to mirror .start/stop calls to
      * @return Timing Handler
      */
-    @NotNull
+    @Contract(value = "_, _, _ -> fail", pure = true) // Plazma - Completely remove timings
+    @Deprecated(forRemoval = true) @DoNotUse // Plazma - Completely remove timings
     public static Timing ofStart(@NotNull Plugin plugin, @NotNull String name, @Nullable Timing groupHandler) {
-        Timing timing = of(plugin, name, groupHandler);
-        //timing.startTiming(); // Purpur - Remove Timings
-        return timing;
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
     }
 
     /**
@@ -133,8 +123,10 @@ public final class Timings {
      *
      * @return Enabled or not
      */
+    @Contract(value = " -> fail", pure = true) // Plazma - Completely remove timings
+    @Deprecated(forRemoval = true) @DoNotUse // Plazma - Completely remove timings
     public static boolean isTimingsEnabled() {
-        return timingsEnabled;
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
     }
 
     /**
@@ -144,28 +136,19 @@ public final class Timings {
      *
      * @param enabled Should timings be reported
      */
+    @Contract(value = "_ -> fail", pure = true) // Plazma - Completely remove timings
+    @Deprecated(forRemoval = true) @DoNotUse // Plazma - Completely remove timings
     public static void setTimingsEnabled(boolean enabled) {
-        if (enabled && !warnedAboutDeprecationOnEnable) {
-            //Bukkit.getLogger().severe(PlainTextComponentSerializer.plainText().serialize(deprecationMessage())); // Purpur - Remove Timings
-            warnedAboutDeprecationOnEnable = true;
-        }
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
     }
 
+    /**
+     * @return The deprecation message.
+     */
+    @Contract(value = " -> fail", pure = true) // Plazma - Completely remove timings
+    @Deprecated(forRemoval = true) @DoNotUse // Plazma - Completely remove timings
     public static Component deprecationMessage() {
-        return Component.text()
-            .color(TextColor.color(0xffc93a))
-            .append(Component.text("[!] The timings profiler is in no-op mode and will be fully removed in a later update."))
-            .append(Component.newline())
-            .append(Component.text("    We recommend migrating to the spark profiler."))
-            .append(Component.newline())
-            .append(
-                Component.text("    For more information please visit: ")
-                    .append(
-                        Component.text()
-                            .content("https://github.com/PaperMC/Paper/discussions/10565")
-                            .clickEvent(ClickEvent.openUrl("https://github.com/PaperMC/Paper/discussions/10565")))
-            )
-            .build();
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
     }
 
     /**
@@ -175,8 +158,10 @@ public final class Timings {
      *
      * @return Enabled or not
      */
+    @Contract(value = " -> fail", pure = true) // Plazma - Completely remove timings
+    @Deprecated(forRemoval = true) @DoNotUse // Plazma - Completely remove timings
     public static boolean isVerboseTimingsEnabled() {
-        return verboseEnabled;
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
     }
 
     /**
@@ -187,9 +172,10 @@ public final class Timings {
      *
      * @param enabled Should high-frequency timings be reported
      */
+    @Contract(value = "_ -> fail", pure = true) // Plazma - Completely remove timings
+    @Deprecated(forRemoval = true) @DoNotUse // Plazma - Completely remove timings
     public static void setVerboseTimingsEnabled(boolean enabled) {
-        verboseEnabled = enabled;
-        TimingsManager.needsRecheckEnabled = true;
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
     }
 
     /**
@@ -199,8 +185,10 @@ public final class Timings {
      *
      * @return Interval in ticks
      */
+    @Contract(value = " -> fail", pure = true) // Plazma - Completely remove timings
+    @Deprecated(forRemoval = true) @DoNotUse // Plazma - Completely remove timings
     public static int getHistoryInterval() {
-        return historyInterval;
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
     }
 
     /**
@@ -213,12 +201,10 @@ public final class Timings {
      *
      * @param interval Interval in ticks
      */
+    @Contract(value = "_ -> fail", pure = true) // Plazma - Completely remove timings
+    @Deprecated(forRemoval = true) @DoNotUse // Plazma - Completely remove timings
     public static void setHistoryInterval(int interval) {
-        historyInterval = Math.max(20*60, interval);
-        // Recheck the history length with the new Interval
-        if (historyLength != -1) {
-            setHistoryLength(historyLength);
-        }
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
     }
 
     /**
@@ -228,8 +214,10 @@ public final class Timings {
      *
      * @return Duration in Ticks
      */
+    @Contract(value = " -> fail", pure = true) // Plazma - Completely remove timings
+    @Deprecated(forRemoval = true) @DoNotUse // Plazma - Completely remove timings
     public static int getHistoryLength() {
-        return historyLength;
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
     }
 
     /**
@@ -243,30 +231,19 @@ public final class Timings {
      *
      * @param length Duration in ticks
      */
+    @Contract(value = "_ -> fail", pure = true) // Plazma - Completely remove timings
+    @Deprecated(forRemoval = true) @DoNotUse // Plazma - Completely remove timings
     public static void setHistoryLength(int length) {
-        // Cap at 12 History Frames, 1 hour at 5 minute frames.
-        int maxLength = historyInterval * MAX_HISTORY_FRAMES;
-        // For special cases of servers with special permission to bypass the max.
-        // This max helps keep data file sizes reasonable for processing on Aikar's Timing parser side.
-        // Setting this will not help you bypass the max unless Aikar has added an exception on the API side.
-        if (System.getProperty("timings.bypassMax") != null) {
-            maxLength = Integer.MAX_VALUE;
-        }
-        historyLength = Math.max(Math.min(maxLength, length), historyInterval);
-        Queue<TimingHistory> oldQueue = TimingsManager.HISTORY;
-        int frames = (getHistoryLength() / getHistoryInterval());
-        if (length > maxLength) {
-            Bukkit.getLogger().log(Level.WARNING, "Timings Length too high. Requested " + length + ", max is " + maxLength + ". To get longer history, you must increase your interval. Set Interval to " + Math.ceil(length / MAX_HISTORY_FRAMES) + " to achieve this length.");
-        }
-        TimingsManager.HISTORY = EvictingQueue.create(frames);
-        TimingsManager.HISTORY.addAll(oldQueue);
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
     }
 
     /**
      * Resets all Timing Data
      */
+    @Contract(value = " -> fail", pure = true) // Plazma - Completely remove timings
+    @Deprecated(forRemoval = true) @DoNotUse // Plazma - Completely remove timings
     public static void reset() {
-        TimingsManager.reset();
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
     }
 
     /**
@@ -275,11 +252,10 @@ public final class Timings {
      * If sender is null, ConsoleCommandSender will be used.
      * @param sender The sender to send to, or null to use the ConsoleCommandSender
      */
+    @Contract(value = "_ -> fail", pure = true) // Plazma - Completely remove timings
+    @Deprecated(forRemoval = true) @DoNotUse // Plazma - Completely remove timings
     public static void generateReport(@Nullable CommandSender sender) {
-        if (sender == null) {
-            sender = Bukkit.getConsoleSender();
-        }
-        requestingReport.add(sender);
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
     }
 
     /**
@@ -287,9 +263,10 @@ public final class Timings {
      * Use with {@link org.bukkit.command.BufferedCommandSender} to get full response when done!
      * @param sender The listener to send responses too.
      */
-    public static void generateReport(@NotNull TimingsReportListener sender) {
-        Preconditions.checkNotNull(sender);
-        requestingReport.add(sender);
+    @Contract(value = "_ -> fail", pure = true) // Plazma - Completely remove timings
+    @Deprecated(forRemoval = true) @DoNotUse // Plazma - Completely remove timings
+    public static void generateReport(@NotNull Object sender) { // Plazma - Completely remove timings
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
     }
 
     /*
@@ -298,6 +275,7 @@ public final class Timings {
     These do not have isPrimaryThread() checks in the startTiming/stopTiming
     =================
     */
+    /* // Plazma - Completely remove timings
     @NotNull
     static TimingHandler ofSafe(@NotNull String name) {
         return ofSafe(null, name, null);
@@ -321,4 +299,5 @@ public final class Timings {
     static TimingHandler ofSafe(@Nullable String groupName, @NotNull String name, @Nullable Timing groupHandler) {
         return TimingsManager.getHandler(groupName, name, groupHandler);
     }
+     */ // Plazma - Completely remove timings
 }
diff --git a/src/main/java/co/aikar/timings/TimingsCommand.java b/src/main/java/co/aikar/timings/TimingsCommand.java
index 04d0dc27406e9f96224f88edb1c535176e84d395..082d897cd86219907c3e8a47a6bae99668d34230 100644
--- a/src/main/java/co/aikar/timings/TimingsCommand.java
+++ b/src/main/java/co/aikar/timings/TimingsCommand.java
@@ -40,31 +40,30 @@ import static net.kyori.adventure.text.Component.text;
  * @deprecated Timings will be removed in the future
  */
 @Deprecated(forRemoval = true)
-public class TimingsCommand extends BukkitCommand {
-    private static final List<String> TIMINGS_SUBCOMMANDS = ImmutableList.of("report", "reset", "on", "off", "paste", "verbon", "verboff");
-    private long lastResetAttempt = 0;
+public final class TimingsCommand extends BukkitCommand { // Plazma - Completely remove timings
+    //private static final List<String> TIMINGS_SUBCOMMANDS = ImmutableList.of("report", "reset", "on", "off", "paste", "verbon", "verboff"); // Plazma - Completely remove timings
+    //private long lastResetAttempt = 0; // Plazma - Completely remove timings
 
     public TimingsCommand(@NotNull String name) {
         super(name);
-        this.description = "Manages Spigot Timings data to see performance of the server.";
+        this.description = "Deprecated command. It should not be used."; // Plazma - Completely remove timings
         this.usageMessage = "/timings";// <reset|report|on|off|verbon|verboff>"; // Purpur - Remove Timings
         this.setPermission("bukkit.command.timings");
     }
 
     @Override
     public boolean execute(@NotNull CommandSender sender, @NotNull String currentAlias, @NotNull String[] args) {
-        if (!testPermission(sender)) {
-            return true;
-        }
-        if (true) {
+        if (testPermission(sender)) { // Plazma - Completely remove timings
             // Purpur start - Remove Timings
             net.kyori.adventure.text.minimessage.MiniMessage mm = net.kyori.adventure.text.minimessage.MiniMessage.miniMessage();
             sender.sendMessage(mm.deserialize("<gold>Purpur has removed timings to save your performance. Please use <click:suggest_command:'/spark'><grey>/spark</grey></click> instead"));
             sender.sendMessage(mm.deserialize("<gold>For more information, view its documentation at"));
             sender.sendMessage(mm.deserialize("<gold><click:open_url:'https://spark.lucko.me/docs/Command-Usage'>https://spark.lucko.me/docs/Command-Usage</click>"));
             // Purpur end - Remove Timings
-            return true;
+            //return true; // Plazma - Completely remove timings
         }
+        return false; // Plazma - Completely remove timings
+        /* // Plazma - Completely remove timings
         if (args.length < 1) {
             sender.sendMessage(text("Usage: " + this.usageMessage, NamedTextColor.RED));
             return true;
@@ -114,8 +113,10 @@ public class TimingsCommand extends BukkitCommand {
             sender.sendMessage(text("Usage: " + this.usageMessage, NamedTextColor.RED));
         }
         return true;
+         */ // Plazma - Completely remove timings
     }
 
+    /* // Plazma - Completely remove timings
     @NotNull
     @Override
     public List<String> tabComplete(@NotNull CommandSender sender, @NotNull String alias, @NotNull String[] args) {
@@ -129,4 +130,5 @@ public class TimingsCommand extends BukkitCommand {
         }
         return ImmutableList.of();
     }
+     */ // Plazma - Completely remove timings
 }
diff --git a/src/main/java/co/aikar/timings/TimingsManager.java b/src/main/java/co/aikar/timings/TimingsManager.java
deleted file mode 100644
index e72ad05abada04426e32a73d02b21cb69079d268..0000000000000000000000000000000000000000
--- a/src/main/java/co/aikar/timings/TimingsManager.java
+++ /dev/null
@@ -1,192 +0,0 @@
-/*
- * This file is licensed under the MIT License (MIT).
- *
- * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package co.aikar.timings;
-
-import co.aikar.util.LoadingMap;
-import com.google.common.collect.EvictingQueue;
-import org.bukkit.Bukkit;
-import org.bukkit.Server;
-import org.bukkit.command.Command;
-import org.bukkit.plugin.Plugin;
-import org.bukkit.plugin.java.PluginClassLoader;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.logging.Level;
-import org.jetbrains.annotations.NotNull;
-import org.jetbrains.annotations.Nullable;
-
-/**
- * @deprecated Timings will be removed in the future
- */
-@Deprecated(forRemoval = true)
-public final class TimingsManager {
-    static final Map<TimingIdentifier, TimingHandler> TIMING_MAP = LoadingMap.of(
-        new ConcurrentHashMap<>(4096, .5F), TimingHandler::new
-    );
-    public static final FullServerTickHandler FULL_SERVER_TICK = new FullServerTickHandler();
-    public static final TimingHandler TIMINGS_TICK = Timings.ofSafe("Timings Tick", FULL_SERVER_TICK);
-    public static final Timing PLUGIN_GROUP_HANDLER = Timings.ofSafe("Plugins");
-    public static String url = "https://timings.aikar.co/";
-    public static List<String> hiddenConfigs = new ArrayList<String>();
-    public static boolean privacy = false;
-
-    static final List<TimingHandler> HANDLERS = new ArrayList<>(1024);
-    static final List<TimingHistory.MinuteReport> MINUTE_REPORTS = new ArrayList<>(64);
-
-    static EvictingQueue<TimingHistory> HISTORY = EvictingQueue.create(12);
-    static long timingStart = 0;
-    static long historyStart = 0;
-    static boolean needsFullReset = false;
-    static boolean needsRecheckEnabled = false;
-
-    private TimingsManager() {}
-
-    /**
-     * Resets all timing data on the next tick
-     */
-    static void reset() {
-        needsFullReset = true;
-    }
-
-    /**
-     * Ticked every tick by CraftBukkit to count the number of times a timer
-     * caused TPS loss.
-     */
-    static void tick() {
-        if (Timings.timingsEnabled) {
-            boolean violated = FULL_SERVER_TICK.isViolated();
-
-            for (TimingHandler handler : HANDLERS) {
-                if (handler.isSpecial()) {
-                    // We manually call this
-                    continue;
-                }
-                handler.processTick(violated);
-            }
-
-            TimingHistory.playerTicks += Bukkit.getOnlinePlayers().size();
-            TimingHistory.timedTicks++;
-            // Generate TPS/Ping/Tick reports every minute
-        }
-    }
-    static void stopServer() {
-        Timings.timingsEnabled = false;
-        recheckEnabled();
-    }
-    static void recheckEnabled() {
-        synchronized (TIMING_MAP) {
-            for (TimingHandler timings : TIMING_MAP.values()) {
-                timings.checkEnabled();
-            }
-        }
-        needsRecheckEnabled = false;
-    }
-    static void resetTimings() {
-        if (needsFullReset) {
-            // Full resets need to re-check every handlers enabled state
-            // Timing map can be modified from async so we must sync on it.
-            synchronized (TIMING_MAP) {
-                for (TimingHandler timings : TIMING_MAP.values()) {
-                    timings.reset(true);
-                }
-            }
-            Bukkit.getLogger().log(Level.INFO, "Timings Reset");
-            HISTORY.clear();
-            needsFullReset = false;
-            needsRecheckEnabled = false;
-            timingStart = System.currentTimeMillis();
-        } else {
-            // Soft resets only need to act on timings that have done something
-            // Handlers can only be modified on main thread.
-            for (TimingHandler timings : HANDLERS) {
-                timings.reset(false);
-            }
-        }
-
-        HANDLERS.clear();
-        MINUTE_REPORTS.clear();
-
-        TimingHistory.resetTicks(true);
-        historyStart = System.currentTimeMillis();
-    }
-
-    @NotNull
-    static TimingHandler getHandler(@Nullable String group, @NotNull String name, @Nullable Timing parent) {
-        return TIMING_MAP.get(new TimingIdentifier(group, name, parent));
-    }
-
-
-    /**
-     * <p>Due to access restrictions, we need a helper method to get a Command TimingHandler with String group</p>
-     *
-     * Plugins should never call this
-     *
-     * @param pluginName Plugin this command is associated with
-     * @param command    Command to get timings for
-     * @return TimingHandler
-     */
-    @NotNull
-    public static Timing getCommandTiming(@Nullable String pluginName, @NotNull Command command) {
-        Plugin plugin = null;
-        final Server server = Bukkit.getServer();
-        if (!(  server == null || pluginName == null ||
-                "minecraft".equals(pluginName) || "bukkit".equals(pluginName) ||
-                "spigot".equalsIgnoreCase(pluginName) || "paper".equals(pluginName)
-        )) {
-            plugin = server.getPluginManager().getPlugin(pluginName);
-        }
-        if (plugin == null) {
-            // Plugin is passing custom fallback prefix, try to look up by class loader
-            plugin = getPluginByClassloader(command.getClass());
-        }
-        if (plugin == null) {
-            return Timings.ofSafe("Command: " + pluginName + ":" + command.getTimingName());
-        }
-
-        return Timings.ofSafe(plugin, "Command: " + pluginName + ":" + command.getTimingName());
-    }
-
-    /**
-     * Looks up the class loader for the specified class, and if it is a PluginClassLoader, return the
-     * Plugin that created this class.
-     *
-     * @param clazz Class to check
-     * @return Plugin if created by a plugin
-     */
-    @Nullable
-    public static Plugin getPluginByClassloader(@Nullable Class<?> clazz) {
-        if (clazz == null) {
-            return null;
-        }
-        final ClassLoader classLoader = clazz.getClassLoader();
-        if (classLoader instanceof PluginClassLoader) {
-            PluginClassLoader pluginClassLoader = (PluginClassLoader) classLoader;
-            return pluginClassLoader.getPlugin();
-        }
-        return null;
-    }
-}
diff --git a/src/main/java/co/aikar/timings/TimingsReportListener.java b/src/main/java/co/aikar/timings/TimingsReportListener.java
deleted file mode 100644
index df066d6f8d55afbc0c1897c486d638657a5f8df9..0000000000000000000000000000000000000000
--- a/src/main/java/co/aikar/timings/TimingsReportListener.java
+++ /dev/null
@@ -1,90 +0,0 @@
-package co.aikar.timings;
-
-import com.google.common.base.Preconditions;
-import com.google.common.collect.Lists;
-import org.bukkit.Bukkit;
-import org.bukkit.command.CommandSender;
-import org.bukkit.command.ConsoleCommandSender;
-import org.bukkit.command.MessageCommandSender;
-import org.bukkit.command.RemoteConsoleCommandSender;
-import org.jetbrains.annotations.NotNull;
-import org.jetbrains.annotations.Nullable;
-
-import java.util.List;
-
-/**
- * @deprecated Timings will be removed in the future
- */
-@Deprecated(forRemoval = true)
-@SuppressWarnings("WeakerAccess")
-public class TimingsReportListener implements net.kyori.adventure.audience.ForwardingAudience, MessageCommandSender {
-    private final List<CommandSender> senders;
-    private final Runnable onDone;
-    private String timingsURL;
-
-    public TimingsReportListener(@NotNull CommandSender senders) {
-        this(senders, null);
-    }
-    public TimingsReportListener(@NotNull CommandSender sender, @Nullable Runnable onDone) {
-        this(Lists.newArrayList(sender), onDone);
-    }
-    public TimingsReportListener(@NotNull List<CommandSender> senders) {
-        this(senders, null);
-    }
-    public TimingsReportListener(@NotNull List<CommandSender> senders, @Nullable Runnable onDone) {
-        Preconditions.checkNotNull(senders);
-        Preconditions.checkArgument(!senders.isEmpty(), "senders is empty");
-
-        this.senders = Lists.newArrayList(senders);
-        this.onDone = onDone;
-    }
-
-    @Nullable
-    public String getTimingsURL() {
-        return timingsURL;
-    }
-
-    public void done() {
-        done(null);
-    }
-
-    public void done(@Nullable String url) {
-        this.timingsURL = url;
-        if (onDone != null) {
-            onDone.run();
-        }
-        for (CommandSender sender : senders) {
-            if (sender instanceof TimingsReportListener) {
-                ((TimingsReportListener) sender).done();
-            }
-        }
-    }
-
-    @Override
-    public void sendMessage(final @NotNull net.kyori.adventure.identity.Identity source, final @NotNull net.kyori.adventure.text.Component message, final @NotNull net.kyori.adventure.audience.MessageType type) {
-        net.kyori.adventure.audience.ForwardingAudience.super.sendMessage(source, message, type);
-    }
-
-    @NotNull
-    @Override
-    public Iterable<? extends net.kyori.adventure.audience.Audience> audiences() {
-        return this.senders;
-    }
-
-    @Override
-    public void sendMessage(@NotNull String message) {
-        senders.forEach((sender) -> sender.sendMessage(message));
-    }
-
-    public void addConsoleIfNeeded() {
-        boolean hasConsole = false;
-        for (CommandSender sender : this.senders) {
-            if (sender instanceof ConsoleCommandSender || sender instanceof RemoteConsoleCommandSender) {
-                hasConsole = true;
-            }
-        }
-        if (!hasConsole) {
-            this.senders.add(Bukkit.getConsoleSender());
-        }
-    }
-}
diff --git a/src/main/java/co/aikar/timings/UnsafeTimingHandler.java b/src/main/java/co/aikar/timings/UnsafeTimingHandler.java
deleted file mode 100644
index 632c4961515f5052551f841cfa840e60bba7a257..0000000000000000000000000000000000000000
--- a/src/main/java/co/aikar/timings/UnsafeTimingHandler.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * This file is licensed under the MIT License (MIT).
- *
- * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package co.aikar.timings;
-
-import org.bukkit.Bukkit;
-import org.jetbrains.annotations.NotNull;
-
-class UnsafeTimingHandler extends TimingHandler {
-
-    UnsafeTimingHandler(@NotNull TimingIdentifier id) {
-        super(id);
-    }
-
-    private static void checkThread() {
-        if (!Bukkit.isPrimaryThread()) {
-            throw new IllegalStateException("Calling Timings from Async Operation");
-        }
-    }
-
-    @NotNull
-    @Override
-    public Timing startTiming() {
-        checkThread();
-        return super.startTiming();
-    }
-
-    @Override
-    public void stopTiming() {
-        checkThread();
-        super.stopTiming();
-    }
-}
diff --git a/src/main/java/co/aikar/util/Counter.java b/src/main/java/co/aikar/util/Counter.java
deleted file mode 100644
index dae84243804b4b076cafb3e1b29bdcf614efc93f..0000000000000000000000000000000000000000
--- a/src/main/java/co/aikar/util/Counter.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package co.aikar.util;
-
-import com.google.common.collect.ForwardingMap;
-
-import java.util.HashMap;
-import java.util.Map;
-import org.jetbrains.annotations.NotNull;
-import org.jetbrains.annotations.Nullable;
-
-@Deprecated(forRemoval = true)
-public class Counter <T> extends ForwardingMap<T, Long> {
-    private final Map<T, Long> counts = new HashMap<>();
-
-    public long decrement(@Nullable T key) {
-        return increment(key, -1);
-    }
-    public long increment(@Nullable T key) {
-        return increment(key, 1);
-    }
-    public long decrement(@Nullable T key, long amount) {
-        return increment(key, -amount);
-    }
-    public long increment(@Nullable T key, long amount) {
-        Long count = this.getCount(key);
-        count += amount;
-        this.counts.put(key, count);
-        return count;
-    }
-
-    public long getCount(@Nullable T key) {
-        return this.counts.getOrDefault(key, 0L);
-    }
-
-    @NotNull
-    @Override
-    protected Map<T, Long> delegate() {
-        return this.counts;
-    }
-}
diff --git a/src/main/java/co/aikar/util/JSONUtil.java b/src/main/java/co/aikar/util/JSONUtil.java
deleted file mode 100644
index c105a1429ca58b37be265708ec345e00f0d43ed8..0000000000000000000000000000000000000000
--- a/src/main/java/co/aikar/util/JSONUtil.java
+++ /dev/null
@@ -1,141 +0,0 @@
-package co.aikar.util;
-
-import com.google.common.base.Function;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
-import org.jetbrains.annotations.NotNull;
-import org.jetbrains.annotations.Nullable;
-import org.json.simple.JSONArray;
-import org.json.simple.JSONObject;
-
-import java.util.ArrayList;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Provides Utility methods that assist with generating JSON Objects
- */
-@SuppressWarnings({"rawtypes", "SuppressionAnnotation"})
-@Deprecated(forRemoval = true)
-public final class JSONUtil {
-    private JSONUtil() {}
-
-    /**
-     * Creates a key/value "JSONPair" object
-     *
-     * @param key Key to use
-     * @param obj Value to use
-     * @return JSONPair
-     */
-    @NotNull
-    public static JSONPair pair(@NotNull String key, @Nullable Object obj) {
-        return new JSONPair(key, obj);
-    }
-
-    @NotNull
-    public static JSONPair pair(long key, @Nullable Object obj) {
-        return new JSONPair(String.valueOf(key), obj);
-    }
-
-    /**
-     * Creates a new JSON object from multiple JSONPair key/value pairs
-     *
-     * @param data JSONPairs
-     * @return Map
-     */
-    @NotNull
-    public static Map<String, Object> createObject(@NotNull JSONPair... data) {
-        return appendObjectData(new LinkedHashMap(), data);
-    }
-
-    /**
-     * This appends multiple key/value Obj pairs into a JSON Object
-     *
-     * @param parent Map to be appended to
-     * @param data Data to append
-     * @return Map
-     */
-    @NotNull
-    public static Map<String, Object> appendObjectData(@NotNull Map parent, @NotNull JSONPair... data) {
-        for (JSONPair JSONPair : data) {
-            parent.put(JSONPair.key, JSONPair.val);
-        }
-        return parent;
-    }
-
-    /**
-     * This builds a JSON array from a set of data
-     *
-     * @param data Data to build JSON array from
-     * @return List
-     */
-    @NotNull
-    public static List toArray(@NotNull Object... data) {
-        return Lists.newArrayList(data);
-    }
-
-    /**
-     * These help build a single JSON array using a mapper function
-     *
-     * @param collection Collection to apply to
-     * @param mapper Mapper to apply
-     * @param <E> Element Type
-     * @return List
-     */
-    @NotNull
-    public static <E> List toArrayMapper(@NotNull E[] collection, @NotNull Function<E, Object> mapper) {
-        return toArrayMapper(Lists.newArrayList(collection), mapper);
-    }
-
-    @NotNull
-    public static <E> List toArrayMapper(@NotNull Iterable<E> collection, @NotNull Function<E, Object> mapper) {
-        List array = Lists.newArrayList();
-        for (E e : collection) {
-            Object object = mapper.apply(e);
-            if (object != null) {
-                array.add(object);
-            }
-        }
-        return array;
-    }
-
-    /**
-     * These help build a single JSON Object from a collection, using a mapper function
-     *
-     * @param collection Collection to apply to
-     * @param mapper Mapper to apply
-     * @param <E> Element Type
-     * @return Map
-     */
-    @NotNull
-    public static <E> Map toObjectMapper(@NotNull E[] collection, @NotNull Function<E, JSONPair> mapper) {
-        return toObjectMapper(Lists.newArrayList(collection), mapper);
-    }
-
-    @NotNull
-    public static <E> Map toObjectMapper(@NotNull Iterable<E> collection, @NotNull Function<E, JSONPair> mapper) {
-        Map object = Maps.newLinkedHashMap();
-        for (E e : collection) {
-            JSONPair JSONPair = mapper.apply(e);
-            if (JSONPair != null) {
-                object.put(JSONPair.key, JSONPair.val);
-            }
-        }
-        return object;
-    }
-
-    /**
-     * Simply stores a key and a value, used internally by many methods below.
-     */
-    @SuppressWarnings("PublicInnerClass")
-    public static class JSONPair {
-        final String key;
-        final Object val;
-
-        JSONPair(@NotNull String key, @NotNull Object val) {
-            this.key = key;
-            this.val = val;
-        }
-    }
-}
diff --git a/src/main/java/co/aikar/util/LoadingIntMap.java b/src/main/java/co/aikar/util/LoadingIntMap.java
deleted file mode 100644
index 5753b9bce89db2ac378ec41f1b61907cc2e23335..0000000000000000000000000000000000000000
--- a/src/main/java/co/aikar/util/LoadingIntMap.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright (c) 2015. Starlis LLC / dba Empire Minecraft
- *
- * This source code is proprietary software and must not be redistributed without Starlis LLC's approval
- *
- */
-package co.aikar.util;
-
-
-import com.google.common.base.Function;
-import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
-import org.jetbrains.annotations.NotNull;
-import org.jetbrains.annotations.Nullable;
-
-/**
- * Allows you to pass a Loader function that when a key is accessed that doesn't exist,
- * automatically loads the entry into the map by calling the loader Function.
- *
- * .get() Will only return null if the Loader can return null.
- *
- * You may pass any backing Map to use.
- *
- * This class is not thread safe and should be wrapped with Collections.synchronizedMap on the OUTSIDE of the LoadingMap if needed.
- *
- * Do not wrap the backing map with Collections.synchronizedMap.
- *
- * @param <V> Value
- */
-@Deprecated(forRemoval = true)
-public class LoadingIntMap<V> extends Int2ObjectOpenHashMap<V> {
-    private final Function<Integer, V> loader;
-
-    public LoadingIntMap(@NotNull Function<Integer, V> loader) {
-        super();
-        this.loader = loader;
-    }
-
-    public LoadingIntMap(int expectedSize, @NotNull Function<Integer, V> loader) {
-        super(expectedSize);
-        this.loader = loader;
-    }
-
-    public LoadingIntMap(int expectedSize, float loadFactor, @NotNull Function<Integer, V> loader) {
-        super(expectedSize, loadFactor);
-        this.loader = loader;
-    }
-
-
-    @Nullable
-    @Override
-    public V get(int key) {
-        V res = super.get(key);
-        if (res == null) {
-            res = loader.apply(key);
-            if (res != null) {
-                put(key, res);
-            }
-        }
-        return res;
-    }
-
-    /**
-     * Due to java stuff, you will need to cast it to (Function) for some cases
-     *
-     * @param <T> Type
-     */
-    public abstract static class Feeder <T> implements Function<T, T> {
-        @Nullable
-        @Override
-        public T apply(@Nullable Object input) {
-            return apply();
-        }
-
-        @Nullable
-        public abstract T apply();
-    }
-}
diff --git a/src/main/java/co/aikar/util/LoadingMap.java b/src/main/java/co/aikar/util/LoadingMap.java
deleted file mode 100644
index 1786eeb5cbeaad75602c9c5649bbcd9b2af5cf81..0000000000000000000000000000000000000000
--- a/src/main/java/co/aikar/util/LoadingMap.java
+++ /dev/null
@@ -1,369 +0,0 @@
-/*
- * This file is licensed under the MIT License (MIT).
- *
- * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package co.aikar.util;
-
-import com.google.common.base.Preconditions;
-import java.lang.reflect.Constructor;
-import java.util.AbstractMap;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.IdentityHashMap;
-import java.util.Map;
-import java.util.Set;
-import java.util.function.Function;
-import org.jetbrains.annotations.NotNull;
-import org.jetbrains.annotations.Nullable;
-
-/**
- * Allows you to pass a Loader function that when a key is accessed that doesn't exists,
- * automatically loads the entry into the map by calling the loader Function.
- *
- * .get() Will only return null if the Loader can return null.
- *
- * You may pass any backing Map to use.
- *
- * This class is not thread safe and should be wrapped with Collections.synchronizedMap on the OUTSIDE of the LoadingMap if needed.
- *
- * Do not wrap the backing map with Collections.synchronizedMap.
- *
- * @param <K> Key
- * @param <V> Value
- */
-@Deprecated(forRemoval = true)
-public class LoadingMap <K, V> extends AbstractMap<K, V> {
-    private final Map<K, V> backingMap;
-    private final java.util.function.Function<K, V> loader;
-
-    /**
-     * Initializes an auto loading map using specified loader and backing map
-     * @param backingMap Map to wrap
-     * @param loader Loader
-     */
-    public LoadingMap(@NotNull Map<K, V> backingMap, @NotNull java.util.function.Function<K, V> loader) {
-        this.backingMap = backingMap;
-        this.loader = loader;
-    }
-
-    /**
-     * Creates a new LoadingMap with the specified map and loader
-     *
-     * @param backingMap Actual map being used.
-     * @param loader Loader to use
-     * @param <K> Key Type of the Map
-     * @param <V> Value Type of the Map
-     * @return Map
-     */
-    @NotNull
-    public static <K, V> Map<K, V> of(@NotNull Map<K, V> backingMap, @NotNull Function<K, V> loader) {
-        return new LoadingMap<>(backingMap, loader);
-    }
-
-    /**
-     * Creates a LoadingMap with an auto instantiating loader.
-     *
-     * Will auto construct class of of Value when not found
-     *
-     * Since this uses Reflection, It is more effecient to define your own static loader
-     * than using this helper, but if performance is not critical, this is easier.
-     *
-     * @param backingMap Actual map being used.
-     * @param keyClass Class used for the K generic
-     * @param valueClass Class used for the V generic
-     * @param <K> Key Type of the Map
-     * @param <V> Value Type of the Map
-     * @return Map that auto instantiates on .get()
-     */
-    @NotNull
-    public static <K, V> Map<K, V> newAutoMap(@NotNull Map<K, V> backingMap, @Nullable final Class<? extends K> keyClass,
-                                              @NotNull final Class<? extends V> valueClass) {
-        return new LoadingMap<>(backingMap, new AutoInstantiatingLoader<>(keyClass, valueClass));
-    }
-    /**
-     * Creates a LoadingMap with an auto instantiating loader.
-     *
-     * Will auto construct class of of Value when not found
-     *
-     * Since this uses Reflection, It is more effecient to define your own static loader
-     * than using this helper, but if performance is not critical, this is easier.
-     *
-     * @param backingMap Actual map being used.
-     * @param valueClass Class used for the V generic
-     * @param <K> Key Type of the Map
-     * @param <V> Value Type of the Map
-     * @return Map that auto instantiates on .get()
-     */
-    @NotNull
-    public static <K, V> Map<K, V> newAutoMap(@NotNull Map<K, V> backingMap,
-                                              @NotNull final Class<? extends V> valueClass) {
-        return newAutoMap(backingMap, null, valueClass);
-    }
-
-    /**
-     * @see #newAutoMap
-     *
-     * new Auto initializing map using a HashMap.
-     *
-     * @param keyClass Class used for the K generic
-     * @param valueClass Class used for the V generic
-     * @param <K> Key Type of the Map
-     * @param <V> Value Type of the Map
-     * @return Map that auto instantiates on .get()
-     */
-    @NotNull
-    public static <K, V> Map<K, V> newHashAutoMap(@Nullable final Class<? extends K> keyClass, @NotNull final Class<? extends V> valueClass) {
-        return newAutoMap(new HashMap<>(), keyClass, valueClass);
-    }
-
-    /**
-     * @see #newAutoMap
-     *
-     * new Auto initializing map using a HashMap.
-     *
-     * @param valueClass Class used for the V generic
-     * @param <K> Key Type of the Map
-     * @param <V> Value Type of the Map
-     * @return Map that auto instantiates on .get()
-     */
-    @NotNull
-    public static <K, V> Map<K, V> newHashAutoMap(@NotNull final Class<? extends V> valueClass) {
-        return newHashAutoMap(null, valueClass);
-    }
-
-    /**
-     * @see #newAutoMap
-     *
-     * new Auto initializing map using a HashMap.
-     *
-     * @param keyClass Class used for the K generic
-     * @param valueClass Class used for the V generic
-     * @param initialCapacity Initial capacity to use
-     * @param loadFactor Load factor to use
-     * @param <K> Key Type of the Map
-     * @param <V> Value Type of the Map
-     * @return Map that auto instantiates on .get()
-     */
-    @NotNull
-    public static <K, V> Map<K, V> newHashAutoMap(@Nullable final Class<? extends K> keyClass, @NotNull final Class<? extends V> valueClass, int initialCapacity, float loadFactor) {
-        return newAutoMap(new HashMap<>(initialCapacity, loadFactor), keyClass, valueClass);
-    }
-
-    /**
-     * @see #newAutoMap
-     *
-     * new Auto initializing map using a HashMap.
-     *
-     * @param valueClass Class used for the V generic
-     * @param initialCapacity Initial capacity to use
-     * @param loadFactor Load factor to use
-     * @param <K> Key Type of the Map
-     * @param <V> Value Type of the Map
-     * @return  Map that auto instantiates on .get()
-     */
-    @NotNull
-    public static <K, V> Map<K, V> newHashAutoMap(@NotNull final Class<? extends V> valueClass, int initialCapacity, float loadFactor) {
-        return newHashAutoMap(null, valueClass, initialCapacity, loadFactor);
-    }
-
-    /**
-     * Initializes an auto loading map using a HashMap
-     *
-     * @param loader Loader to use
-     * @param <K> Key Type of the Map
-     * @param <V> Value Type of the Map
-     * @return Map
-     */
-    @NotNull
-    public static <K, V> Map<K, V> newHashMap(@NotNull Function<K, V> loader) {
-        return new LoadingMap<>(new HashMap<>(), loader);
-    }
-
-    /**
-     * Initializes an auto loading map using a HashMap
-     *
-     * @param loader Loader to use
-     * @param initialCapacity Initial capacity to use
-     * @param <K> Key Type of the Map
-     * @param <V> Value Type of the Map
-     * @return Map
-     */
-    @NotNull
-    public static <K, V> Map<K, V> newHashMap(@NotNull Function<K, V> loader, int initialCapacity) {
-        return new LoadingMap<>(new HashMap<>(initialCapacity), loader);
-    }
-    /**
-     * Initializes an auto loading map using a HashMap
-     *
-     * @param loader Loader to use
-     * @param initialCapacity Initial capacity to use
-     * @param loadFactor Load factor to use
-     * @param <K> Key Type of the Map
-     * @param <V> Value Type of the Map
-     * @return Map
-     */
-    @NotNull
-    public static <K, V> Map<K, V> newHashMap(@NotNull Function<K, V> loader, int initialCapacity, float loadFactor) {
-        return new LoadingMap<>(new HashMap<>(initialCapacity, loadFactor), loader);
-    }
-
-    /**
-     * Initializes an auto loading map using an Identity HashMap
-     *
-     * @param loader Loader to use
-     * @param <K> Key Type of the Map
-     * @param <V> Value Type of the Map
-     * @return Map
-     */
-    @NotNull
-    public static <K, V> Map<K, V> newIdentityHashMap(@NotNull Function<K, V> loader) {
-        return new LoadingMap<>(new IdentityHashMap<>(), loader);
-    }
-
-    /**
-     * Initializes an auto loading map using an Identity HashMap
-     *
-     * @param loader Loader to use
-     * @param initialCapacity Initial capacity to use
-     * @param <K> Key Type of the Map
-     * @param <V> Value Type of the Map
-     * @return Map
-     */
-    @NotNull
-    public static <K, V> Map<K, V> newIdentityHashMap(@NotNull Function<K, V> loader, int initialCapacity) {
-        return new LoadingMap<>(new IdentityHashMap<>(initialCapacity), loader);
-    }
-
-    @Override
-    public int size() {return backingMap.size();}
-
-    @Override
-    public boolean isEmpty() {return backingMap.isEmpty();}
-
-    @Override
-    public boolean containsKey(@Nullable Object key) {return backingMap.containsKey(key);}
-
-    @Override
-    public boolean containsValue(@Nullable Object value) {return backingMap.containsValue(value);}
-
-    @Nullable
-    @Override
-    public V get(@Nullable Object key) {
-        V v = backingMap.get(key);
-        if (v != null) {
-            return v;
-        }
-        return backingMap.computeIfAbsent((K) key, loader);
-    }
-
-    @Nullable
-    public V put(@Nullable K key, @Nullable V value) {return backingMap.put(key, value);}
-
-    @Nullable
-    @Override
-    public V remove(@Nullable Object key) {return backingMap.remove(key);}
-
-    public void putAll(@NotNull Map<? extends K, ? extends V> m) {backingMap.putAll(m);}
-
-    @Override
-    public void clear() {backingMap.clear();}
-
-    @NotNull
-    @Override
-    public Set<K> keySet() {return backingMap.keySet();}
-
-    @NotNull
-    @Override
-    public Collection<V> values() {return backingMap.values();}
-
-    @Override
-    public boolean equals(@Nullable Object o) {return backingMap.equals(o);}
-
-    @Override
-    public int hashCode() {return backingMap.hashCode();}
-
-    @NotNull
-    @Override
-    public Set<Entry<K, V>> entrySet() {
-        return backingMap.entrySet();
-    }
-
-    @NotNull
-    public LoadingMap<K, V> clone() {
-        return new LoadingMap<>(backingMap, loader);
-    }
-
-    private static class AutoInstantiatingLoader<K, V> implements Function<K, V> {
-        final Constructor<? extends V> constructor;
-        private final Class<? extends V> valueClass;
-
-        AutoInstantiatingLoader(@Nullable Class<? extends K> keyClass, @NotNull Class<? extends V> valueClass) {
-            try {
-                this.valueClass = valueClass;
-                if (keyClass != null) {
-                    constructor = valueClass.getConstructor(keyClass);
-                } else {
-                    constructor = null;
-                }
-            } catch (NoSuchMethodException e) {
-                throw new IllegalStateException(
-                    valueClass.getName() + " does not have a constructor for " + (keyClass != null ? keyClass.getName() : null));
-            }
-        }
-
-        @NotNull
-        @Override
-        public V apply(@Nullable K input) {
-            try {
-                return (constructor != null ? constructor.newInstance(input) : valueClass.newInstance());
-            } catch (Exception e) {
-                throw new ExceptionInInitializerError(e);
-            }
-        }
-
-        @Override
-        public int hashCode() {
-            return super.hashCode();
-        }
-
-        @Override
-        public boolean equals(Object object) {
-            return false;
-        }
-    }
-
-    /**
-     * Due to java stuff, you will need to cast it to (Function) for some cases
-     *
-     * @param <T> Type
-     */
-    public abstract static class Feeder <T> implements Function<T, T> {
-        @Nullable
-        @Override
-        public T apply(@Nullable Object input) {
-            return apply();
-        }
-
-        @Nullable
-        public abstract T apply();
-    }
-}
diff --git a/src/main/java/co/aikar/util/MRUMapCache.java b/src/main/java/co/aikar/util/MRUMapCache.java
deleted file mode 100644
index 3e61a926620a67daec3af54b72a1b911eaef2ed4..0000000000000000000000000000000000000000
--- a/src/main/java/co/aikar/util/MRUMapCache.java
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- * This file is licensed under the MIT License (MIT).
- *
- * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package co.aikar.util;
-
-import java.util.AbstractMap;
-import java.util.Collection;
-import java.util.Map;
-import java.util.Set;
-import org.jetbrains.annotations.NotNull;
-import org.jetbrains.annotations.Nullable;
-
-/**
- * Implements a Most Recently Used cache in front of a backing map, to quickly access the last accessed result.
- *
- * @param <K> Key Type of the Map
- * @param <V> Value Type of the Map
- */
-@Deprecated(forRemoval = true)
-public class MRUMapCache<K, V> extends AbstractMap<K, V> {
-    final Map<K, V> backingMap;
-    Object cacheKey;
-    V cacheValue;
-    public MRUMapCache(@NotNull final Map<K, V> backingMap) {
-        this.backingMap = backingMap;
-    }
-
-    public int size() {return backingMap.size();}
-
-    public boolean isEmpty() {return backingMap.isEmpty();}
-
-    public boolean containsKey(@Nullable Object key) {
-        return key != null && key.equals(cacheKey) || backingMap.containsKey(key);
-    }
-
-    public boolean containsValue(@Nullable Object value) {
-        return value != null && value == cacheValue || backingMap.containsValue(value);
-    }
-
-    @Nullable
-    public V get(@Nullable Object key) {
-        if (cacheKey != null && cacheKey.equals(key)) {
-            return cacheValue;
-        }
-        cacheKey = key;
-        return cacheValue = backingMap.get(key);
-    }
-
-    @Nullable
-    public V put(@Nullable K key, @Nullable V value) {
-        cacheKey = key;
-        return cacheValue = backingMap.put(key, value);
-    }
-
-    @Nullable
-    public V remove(@Nullable Object key) {
-        if (key != null && key.equals(cacheKey)) {
-            cacheKey = null;
-        }
-        return backingMap.remove(key);
-    }
-
-    public void putAll(@NotNull Map<? extends K, ? extends V> m) {backingMap.putAll(m);}
-
-    public void clear() {
-        cacheKey = null;
-        cacheValue = null;
-        backingMap.clear();
-    }
-
-    @NotNull
-    public Set<K> keySet() {return backingMap.keySet();}
-
-    @NotNull
-    public Collection<V> values() {return backingMap.values();}
-
-    @NotNull
-    public Set<Map.Entry<K, V>> entrySet() {return backingMap.entrySet();}
-
-    /**
-     * Wraps the specified map with a most recently used cache
-     *
-     * @param map Map to be wrapped
-     * @param <K> Key Type of the Map
-     * @param <V> Value Type of the Map
-     * @return Map
-     */
-    @NotNull
-    public static <K, V> Map<K, V> of(@NotNull Map<K, V> map) {
-        return new MRUMapCache<K, V>(map);
-    }
-}
diff --git a/src/main/java/org/bukkit/command/Command.java b/src/main/java/org/bukkit/command/Command.java
index 71eb845a4d3b8b6ec3b816a0f20ec807e0f9a86d..d16d1d6b9b625e0843f17c60b40e1c2df81fe378 100644
--- a/src/main/java/org/bukkit/command/Command.java
+++ b/src/main/java/org/bukkit/command/Command.java
@@ -16,6 +16,7 @@ import org.bukkit.entity.minecart.CommandMinecart;
 import org.bukkit.permissions.Permissible;
 import org.bukkit.plugin.PluginDescriptionFile;
 import org.bukkit.util.StringUtil;
+import org.jetbrains.annotations.Contract;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
@@ -42,7 +43,7 @@ public abstract class Command {
      * @deprecated Timings will be removed in the future
      */
     @Deprecated(forRemoval = true)
-    @NotNull public String getTimingName() {return getName();} // Paper
+    @Contract(value = " -> fail", pure = true) @NotNull public final String getTimingName() {throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead.");} // Paper // Plazma - Completely remove timings
 
     protected Command(@NotNull String name) {
         this(name, "", "/" + name, new ArrayList<String>());
diff --git a/src/main/java/org/bukkit/command/FormattedCommandAlias.java b/src/main/java/org/bukkit/command/FormattedCommandAlias.java
index abe256e1e45ce28036da4aa1586715bc8a1a3414..0ce5ecb25703b568e62cdd52ba61ae35d9e27d9f 100644
--- a/src/main/java/org/bukkit/command/FormattedCommandAlias.java
+++ b/src/main/java/org/bukkit/command/FormattedCommandAlias.java
@@ -12,7 +12,7 @@ public class FormattedCommandAlias extends Command {
 
     public FormattedCommandAlias(@NotNull String alias, @NotNull String[] formatStrings) {
         super(alias);
-        timings = co.aikar.timings.TimingsManager.getCommandTiming("minecraft", this); // Spigot
+        //timings = co.aikar.timings.TimingsManager.getCommandTiming("minecraft", this); // Spigot // Plazma - Completely remove timings
         this.formatStrings = formatStrings;
     }
 
@@ -120,9 +120,11 @@ public class FormattedCommandAlias extends Command {
         return formatString.trim(); // Paper - Causes an extra space at the end, breaks with brig commands
     }
 
+    /* // Plazma - Completely remove timings
     @NotNull
     @Override // Paper
     public String getTimingName() {return "Command Forwarder - " + super.getTimingName();} // Paper
+     */ // Plazma - Completely remove timings
 
     private static boolean inRange(int i, int j, int k) {
         return i >= j && i <= k;
diff --git a/src/main/java/org/bukkit/command/SimpleCommandMap.java b/src/main/java/org/bukkit/command/SimpleCommandMap.java
index 685aa9d73f14a5e3a85b251b83fbe8134b0a244c..24e99ec28607bf807456cfc1ff47bec991b45ef9 100644
--- a/src/main/java/org/bukkit/command/SimpleCommandMap.java
+++ b/src/main/java/org/bukkit/command/SimpleCommandMap.java
@@ -71,7 +71,7 @@ public class SimpleCommandMap implements CommandMap {
      */
     @Override
     public boolean register(@NotNull String label, @NotNull String fallbackPrefix, @NotNull Command command) {
-        command.timings = co.aikar.timings.TimingsManager.getCommandTiming(fallbackPrefix, command); // Paper
+        //command.timings = co.aikar.timings.TimingsManager.getCommandTiming(fallbackPrefix, command); // Paper // Plazma - Completely remove timings
         label = label.toLowerCase(Locale.ROOT).trim();
         fallbackPrefix = fallbackPrefix.toLowerCase(Locale.ROOT).trim();
         boolean registered = register(label, command, false, fallbackPrefix);
@@ -166,11 +166,13 @@ public class SimpleCommandMap implements CommandMap {
         parsedArgs = event.getArgs();
         // Purpur end - ExecuteCommandEvent
 
+        /* // Plazma - Completely remove timings
         // Paper start - Plugins do weird things to workaround normal registration
         if (target.timings == null) {
             target.timings = co.aikar.timings.TimingsManager.getCommandTiming(null, target);
         }
         // Paper end
+         */ // Plazma - Completely remove timings
 
         try {
             //try (co.aikar.timings.Timing ignored = target.timings.startTiming()) { // Paper - use try with resources // Purpur - Remove Timings
diff --git a/src/main/java/org/bukkit/plugin/PluginManager.java b/src/main/java/org/bukkit/plugin/PluginManager.java
index 47153dee66782a00b980ecf15e8774ab6f3d887d..d996f70fdbf2b50da89a058786eb5bfb2c68cfd7 100644
--- a/src/main/java/org/bukkit/plugin/PluginManager.java
+++ b/src/main/java/org/bukkit/plugin/PluginManager.java
@@ -312,7 +312,8 @@ public interface PluginManager extends io.papermc.paper.plugin.PermissionManager
      *
      * @return True if event timings are to be used
      */
-    public boolean useTimings();
+    @Deprecated(forRemoval = true) @io.papermc.paper.annotation.DoNotUse // Plazma - Completely remove timings
+    default boolean useTimings() { throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); } // Plazma - Completely remove timings
 
     // Paper start
     @org.jetbrains.annotations.ApiStatus.Internal
diff --git a/src/main/java/org/bukkit/plugin/SimplePluginManager.java b/src/main/java/org/bukkit/plugin/SimplePluginManager.java
index 001465eedafa51ac027a4db51cba6223edfe1171..9f2ca17201a4fcef3d0ce1895e3f7c4ec8f4979a 100644
--- a/src/main/java/org/bukkit/plugin/SimplePluginManager.java
+++ b/src/main/java/org/bukkit/plugin/SimplePluginManager.java
@@ -61,7 +61,7 @@ public final class SimplePluginManager implements PluginManager {
     public final Map<Boolean, Map<Permissible, Boolean>> defSubs = new HashMap<Boolean, Map<Permissible, Boolean>>();
     public PluginManager paperPluginManager;
     // Paper end
-    private boolean useTimings = false;
+    //private boolean useTimings = false; // Plazma - Completely remove timings
 
     public SimplePluginManager(@NotNull Server instance, @NotNull SimpleCommandMap commandMap) {
         server = instance;
@@ -720,12 +720,7 @@ public final class SimplePluginManager implements PluginManager {
             throw new IllegalPluginAccessException("Plugin attempted to register " + event + " while not enabled");
         }
 
-        executor = new co.aikar.timings.TimedEventExecutor(executor, plugin, null, event); // Paper
-        if (false) { // Spigot - RL handles useTimings check now // Paper
-            getEventListeners(event).register(new TimedRegisteredListener(listener, executor, priority, plugin, ignoreCancelled));
-        } else {
-            getEventListeners(event).register(new RegisteredListener(listener, executor, priority, plugin, ignoreCancelled));
-        }
+        getEventListeners(event).register(new RegisteredListener(listener, executor, priority, plugin, ignoreCancelled)); // Plazma - Completely remove timings
     }
 
     @NotNull
@@ -953,21 +948,18 @@ public final class SimplePluginManager implements PluginManager {
         return false;
     }
 
+    /* // Plazma - Completely remove timings
     @Override
     public boolean useTimings() {
         if (true) {return this.paperPluginManager.useTimings();} // Paper
         return co.aikar.timings.Timings.isTimingsEnabled(); // Spigot
     }
 
-    /**
-     * Sets whether or not per event timing code should be used
-     *
-     * @param use True if per event timing code should be used
-     */
     @Deprecated(forRemoval = true)
     public void useTimings(boolean use) {
         co.aikar.timings.Timings.setTimingsEnabled(use); // Paper
     }
+     */ // Plazma - Completely remove timings
 
     // Paper start
     public void clearPermissions() {
diff --git a/src/main/java/org/bukkit/plugin/TimedRegisteredListener.java b/src/main/java/org/bukkit/plugin/TimedRegisteredListener.java
index 1d76e30b82ca56bb4cf3b9a33f5a129ab829e3f0..14cf79a8d9af96811b8e1bf1b12f17c902f1913f 100644
--- a/src/main/java/org/bukkit/plugin/TimedRegisteredListener.java
+++ b/src/main/java/org/bukkit/plugin/TimedRegisteredListener.java
@@ -7,38 +7,28 @@ import org.bukkit.event.Listener;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
+import org.jetbrains.annotations.Contract; // Plazma - Completely remove timings
+import io.papermc.paper.annotation.DoNotUse; // Plazma - Completely remove timings
+
 /**
  * Extends RegisteredListener to include timing information
  */
-public class TimedRegisteredListener extends RegisteredListener {
-    private int count;
-    private long totalTime;
-    private Class<? extends Event> eventClass;
-    private boolean multiple = false;
+@Deprecated(forRemoval = true) // Plazma - Completely remove timings
+public final class TimedRegisteredListener extends RegisteredListener { // Plazma - Completely remove timings
 
+    @Contract(value = "_, _, _, _, _ -> fail", pure = true) @Deprecated(forRemoval = true) @DoNotUse // Plazma - Completely remove timings
     public TimedRegisteredListener(@NotNull final Listener pluginListener, @NotNull final EventExecutor eventExecutor, @NotNull final EventPriority eventPriority, @NotNull final Plugin registeredPlugin, final boolean listenCancelled) {
         super(pluginListener, eventExecutor, eventPriority, registeredPlugin, listenCancelled);
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
     }
 
+    @Contract(value = "_ -> fail", pure = true) @Deprecated(forRemoval = true) @DoNotUse // Plazma - Completely remove timings
     @Override
     public void callEvent(@NotNull Event event) throws EventException {
-        if (event.isAsynchronous()) {
-            super.callEvent(event);
-            return;
-        }
-        count++;
-        Class<? extends Event> newEventClass = event.getClass();
-        if (this.eventClass == null) {
-            this.eventClass = newEventClass;
-        } else if (!this.eventClass.equals(newEventClass)) {
-            multiple = true;
-            this.eventClass = getCommonSuperclass(newEventClass, this.eventClass).asSubclass(Event.class);
-        }
-        long start = System.nanoTime();
-        super.callEvent(event);
-        totalTime += System.nanoTime() - start;
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
     }
 
+    /* // Plazma - Completely remove timings
     @NotNull
     private static Class<?> getCommonSuperclass(@NotNull Class<?> class1, @NotNull Class<?> class2) {
         while (!class1.isAssignableFrom(class2)) {
@@ -46,13 +36,14 @@ public class TimedRegisteredListener extends RegisteredListener {
         }
         return class1;
     }
+     */ // Plazma - Completely remove timings
 
     /**
      * Resets the call count and total time for this listener
      */
+    @Contract(value = " -> fail", pure = true) @Deprecated(forRemoval = true) @DoNotUse // Plazma - Completely remove timings
     public void reset() {
-        count = 0;
-        totalTime = 0;
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
     }
 
     /**
@@ -60,8 +51,9 @@ public class TimedRegisteredListener extends RegisteredListener {
      *
      * @return Times this listener has been called
      */
+    @Contract(value = " -> fail", pure = true) @Deprecated(forRemoval = true) @DoNotUse // Plazma - Completely remove timings
     public int getCount() {
-        return count;
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
     }
 
     /**
@@ -69,8 +61,9 @@ public class TimedRegisteredListener extends RegisteredListener {
      *
      * @return Total time for all calls of this listener
      */
+    @Contract(value = " -> fail", pure = true) @Deprecated(forRemoval = true) @DoNotUse // Plazma - Completely remove timings
     public long getTotalTime() {
-        return totalTime;
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
     }
 
     /**
@@ -84,9 +77,10 @@ public class TimedRegisteredListener extends RegisteredListener {
      *
      * @return the event class handled by this RegisteredListener
      */
+    @Contract(value = " -> fail", pure = true) @Deprecated(forRemoval = true) @DoNotUse // Plazma - Completely remove timings
     @Nullable
     public Class<? extends Event> getEventClass() {
-        return eventClass;
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
     }
 
     /**
@@ -95,7 +89,8 @@ public class TimedRegisteredListener extends RegisteredListener {
      *
      * @return true if this listener has handled multiple events
      */
+    @Contract(value = " -> fail", pure = true) @Deprecated(forRemoval = true) @DoNotUse // Plazma - Completely remove timings
     public boolean hasMultiple() {
-        return multiple;
+        throw new UnsupportedOperationException("Timings feature was removed from Plazma. Use Spark instead."); // Plazma - Completely remove timings
     }
 }
diff --git a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
index 065f182fbfe4541d602f57d548f286ee3c2fab19..fc62bd441f78417cad13eaa07a3f036d1c38bb30 100644
--- a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
@@ -39,11 +39,11 @@ import org.bukkit.plugin.PluginDescriptionFile;
 import org.bukkit.plugin.PluginLoader;
 import org.bukkit.plugin.RegisteredListener;
 import org.bukkit.plugin.SimplePluginManager;
-import org.bukkit.plugin.TimedRegisteredListener;
+//import org.bukkit.plugin.TimedRegisteredListener; // Plazma - Completely remove timings
 import org.bukkit.plugin.UnknownDependencyException;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
-import org.spigotmc.CustomTimingsHandler; // Spigot
+//import org.spigotmc.CustomTimingsHandler; // Spigot // Plazma - Completely remove timings
 import org.yaml.snakeyaml.error.YAMLException;
 
 /**
@@ -233,7 +233,7 @@ public final class JavaPluginLoader implements PluginLoader {
         Preconditions.checkArgument(plugin != null, "Plugin can not be null");
         Preconditions.checkArgument(listener != null, "Listener can not be null");
 
-        boolean useTimings = server.getPluginManager().useTimings();
+        //boolean useTimings = server.getPluginManager().useTimings(); // Plazma - Completely remove timings
         Map<Class<? extends Event>, Set<RegisteredListener>> ret = new HashMap<Class<? extends Event>, Set<RegisteredListener>>();
         Set<Method> methods;
         try {
@@ -294,7 +294,7 @@ public final class JavaPluginLoader implements PluginLoader {
                 }
             }
 
-            EventExecutor executor = new co.aikar.timings.TimedEventExecutor(new EventExecutor() { // Paper
+            EventExecutor executor = new EventExecutor() { // Paper // Plazma - Completely remove timings
                 @Override
                 public void execute(@NotNull Listener listener, @NotNull Event event) throws EventException { // Paper
                     try {
@@ -308,12 +308,8 @@ public final class JavaPluginLoader implements PluginLoader {
                         throw new EventException(t);
                     }
                 }
-            }, plugin, method, eventClass); // Paper
-            if (false) { // Spigot - RL handles useTimings check now
-                eventSet.add(new TimedRegisteredListener(listener, executor, eh.priority(), plugin, eh.ignoreCancelled()));
-            } else {
-                eventSet.add(new RegisteredListener(listener, executor, eh.priority(), plugin, eh.ignoreCancelled()));
-            }
+            }; // Paper // Plazma - Completely remove timings
+            eventSet.add(new RegisteredListener(listener, executor, eh.priority(), plugin, eh.ignoreCancelled())); // Plazma - Completely remove timings
         }
         return ret;
     }
diff --git a/src/main/java/org/spigotmc/CustomTimingsHandler.java b/src/main/java/org/spigotmc/CustomTimingsHandler.java
deleted file mode 100644
index b4249da3eb26eae26ec000cc4d56cd21ac2fc6d5..0000000000000000000000000000000000000000
--- a/src/main/java/org/spigotmc/CustomTimingsHandler.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * This file is licensed under the MIT License (MIT).
- *
- * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package org.spigotmc;
-
-import org.bukkit.Bukkit;
-import org.jetbrains.annotations.NotNull;
-import org.bukkit.plugin.AuthorNagException;
-import co.aikar.timings.Timing;
-import co.aikar.timings.Timings;
-import co.aikar.timings.TimingsManager;
-
-import java.lang.reflect.Method;
-import java.util.logging.Level;
-
-/**
- * This is here for legacy purposes incase any plugin used it.
- *
- * If you use this, migrate ASAP as this will be removed in the future!
- *
- * @deprecated
- * @see co.aikar.timings.Timings#of
- */
-@Deprecated(forRemoval = true)
-public final class CustomTimingsHandler {
-    private final Timing handler;
-
-    public CustomTimingsHandler(@NotNull String name) {
-        Timing timing;
-
-        new AuthorNagException("Deprecated use of CustomTimingsHandler. Timings has been removed.").printStackTrace();
-        try {
-            final Method ofSafe = TimingsManager.class.getDeclaredMethod("getHandler", String.class, String.class, Timing.class);
-            ofSafe.setAccessible(true);
-            timing = (Timing) ofSafe.invoke(null,"Minecraft", "(Deprecated API) " + name, null);
-        } catch (Exception e) {
-            e.printStackTrace();
-            Bukkit.getLogger().log(Level.SEVERE, "This handler could not be registered");
-            timing = Timings.NULL_HANDLER;
-        }
-        handler = timing;
-    }
-
-    public void startTiming() { /*handler.startTiming();*/ } // Purpur - Remove Timings
-    public void stopTiming() { /*handler.stopTiming();*/ } // Purpur - Remove Timings
-
-}
diff --git a/src/test/java/org/bukkit/AnnotationTest.java b/src/test/java/org/bukkit/AnnotationTest.java
index 37feafd626aaa17aba888d7ff13728b3c6f26d4d..c840d3efe018754d3188a4ed3dae9104044bd2a7 100644
--- a/src/test/java/org/bukkit/AnnotationTest.java
+++ b/src/test/java/org/bukkit/AnnotationTest.java
@@ -50,14 +50,6 @@ public class AnnotationTest {
         // Paper start
         "io/papermc/paper/util/TransformingRandomAccessList",
         "io/papermc/paper/util/TransformingRandomAccessList$TransformedListIterator",
-        // Timings history is broken in terms of nullability due to guavas Function defining that the param is NonNull
-        "co/aikar/timings/TimingHistory$2",
-        "co/aikar/timings/TimingHistory$2$1",
-        "co/aikar/timings/TimingHistory$2$1$1",
-        "co/aikar/timings/TimingHistory$2$1$2",
-        "co/aikar/timings/TimingHistory$3",
-        "co/aikar/timings/TimingHistory$4",
-        "co/aikar/timings/TimingHistoryEntry$1"
         // Paper end
     };
 
diff --git a/src/test/java/org/bukkit/plugin/TimedRegisteredListenerTest.java b/src/test/java/org/bukkit/plugin/TimedRegisteredListenerTest.java
deleted file mode 100644
index 9ed416ed57676c845833736f93ed6088513c6da4..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/plugin/TimedRegisteredListenerTest.java
+++ /dev/null
@@ -1,56 +0,0 @@
-package org.bukkit.plugin;
-
-import static org.bukkit.support.MatcherAssert.*;
-import static org.hamcrest.Matchers.*;
-import org.bukkit.event.Event;
-import org.bukkit.event.EventException;
-import org.bukkit.event.EventPriority;
-import org.bukkit.event.Listener;
-import org.bukkit.event.block.BlockBreakEvent;
-import org.bukkit.event.player.PlayerEvent;
-import org.bukkit.event.player.PlayerInteractEvent;
-import org.bukkit.event.player.PlayerMoveEvent;
-import org.junit.jupiter.api.Test;
-
-public class TimedRegisteredListenerTest {
-
-    @Test
-    public void testEventClass() throws EventException {
-        Listener listener = new Listener() {};
-        EventExecutor executor = new EventExecutor() {
-            @Override
-            public void execute(Listener listener, Event event) {}
-        };
-        TestPlugin plugin = new TestPlugin("Test");
-
-        PlayerInteractEvent interactEvent = new PlayerInteractEvent(null, null, null, null, null);
-        PlayerMoveEvent moveEvent = new PlayerMoveEvent(null, null, null);
-        BlockBreakEvent breakEvent = new BlockBreakEvent(null, null);
-
-        TimedRegisteredListener trl = new TimedRegisteredListener(listener, executor, EventPriority.NORMAL, plugin, false);
-
-        // Ensure that the correct event type is reported for a single event
-        trl.callEvent(interactEvent);
-        assertThat(trl.getEventClass(), is((Object) PlayerInteractEvent.class));
-        // Ensure that no superclass is used in lieu of the actual event, after two identical event types
-        trl.callEvent(interactEvent);
-        assertThat(trl.getEventClass(), is((Object) PlayerInteractEvent.class));
-        // Ensure that the closest superclass of the two events is chosen
-        trl.callEvent(moveEvent);
-        assertThat(trl.getEventClass(), is((Object) PlayerEvent.class));
-        // As above, so below
-        trl.callEvent(breakEvent);
-        assertThat(trl.getEventClass(), is((Object) Event.class));
-        // In the name of being thorough, check that it never travels down the hierarchy again.
-        trl.callEvent(breakEvent);
-        assertThat(trl.getEventClass(), is((Object) Event.class));
-
-        trl = new TimedRegisteredListener(listener, executor, EventPriority.NORMAL, plugin, false);
-
-        trl.callEvent(breakEvent);
-        assertThat(trl.getEventClass(), is((Object) BlockBreakEvent.class));
-        // Test moving up the class hierarchy by more than one class at a time
-        trl.callEvent(moveEvent);
-        assertThat(trl.getEventClass(), is((Object) Event.class));
-    }
-}
