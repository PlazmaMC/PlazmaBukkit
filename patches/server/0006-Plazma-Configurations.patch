From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: AlphaKR93 <dev@alpha93.kr>
Date: Fri, 3 Nov 2023 00:11:50 +0900
Subject: [PATCH] Plazma Configurations


diff --git a/src/main/java/io/papermc/paper/configuration/Configurations.java b/src/main/java/io/papermc/paper/configuration/Configurations.java
index 9ef6712c70fcd8912a79f3f61e351aac09572cf3..2e79f87eb10ff1cfe65fdf2ea538734738d474b6 100644
--- a/src/main/java/io/papermc/paper/configuration/Configurations.java
+++ b/src/main/java/io/papermc/paper/configuration/Configurations.java
@@ -1,14 +1,19 @@
 package io.papermc.paper.configuration;
 
+import com.google.common.base.Suppliers;
 import com.mojang.logging.LogUtils;
 import io.leangen.geantyref.TypeToken;
 import io.papermc.paper.configuration.constraint.Constraint;
 import io.papermc.paper.configuration.constraint.Constraints;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.level.ServerLevel;
+import org.apache.commons.lang3.RandomStringUtils;
 import org.checkerframework.checker.nullness.qual.Nullable;
 import org.jetbrains.annotations.MustBeInvokedByOverriders;
+import org.jetbrains.annotations.VisibleForTesting;
 import org.slf4j.Logger;
+import org.spigotmc.SpigotConfig;
+import org.spigotmc.SpigotWorldConfig;
 import org.spongepowered.configurate.CommentedConfigurationNode;
 import org.spongepowered.configurate.ConfigurateException;
 import org.spongepowered.configurate.ConfigurationNode;
@@ -27,8 +32,11 @@ import java.util.HashMap;
 import java.util.Map;
 import java.util.NoSuchElementException;
 import java.util.Objects;
+import java.util.function.Supplier;
 import java.util.function.UnaryOperator;
 
+import static io.leangen.geantyref.GenericTypeReflector.erase;
+
 public abstract class Configurations<G, W> {
 
     private static final Logger LOGGER = LogUtils.getClassLogger();
@@ -40,6 +48,18 @@ public abstract class Configurations<G, W> {
     protected final String globalConfigFileName;
     protected final String defaultWorldConfigFileName;
     protected final String worldConfigFileName;
+    // Plazma start
+    public static final String CONFIG_DIR = "config";
+    protected static final ContextKey<java.util.function.Supplier<org.spigotmc.SpigotWorldConfig>> SPIGOT_WORLD_CONFIG_CONTEXT_KEY = new ContextKey<>(new TypeToken<>() {}, "spigot world config");
+
+    @VisibleForTesting
+    public static final Supplier<SpigotWorldConfig> SPIGOT_WORLD_DEFAULTS = Suppliers.memoize(() -> new SpigotWorldConfig(RandomStringUtils.randomAlphabetic(255)) {
+        @Override // override to ensure "verbose" is false
+        public void init() {
+            SpigotConfig.readConfig(SpigotWorldConfig.class, this);
+        }
+    });
+    // Plazma end
 
     public Configurations(
         final Path globalFolder,
@@ -63,15 +83,31 @@ public abstract class Configurations<G, W> {
             .addConstraint(Constraints.Min.class, Number.class, new Constraints.Min.Factory());
     }
 
+    // Plazma start - Moved from PaperConfigurations.java
     protected YamlConfigurationLoader.Builder createLoaderBuilder() {
-        return ConfigurationLoaders.naturallySorted();
+        return ConfigurationLoaders.naturallySorted().defaultOptions(Configurations::defaultOptions);
+    }
+
+    protected static ConfigurationOptions defaultOptions(ConfigurationOptions options) {
+        return options.serializers(builder -> builder
+                .register(io.papermc.paper.configuration.serializer.collections.MapSerializer.TYPE, new io.papermc.paper.configuration.serializer.collections.MapSerializer(false))
+                .register(new io.papermc.paper.configuration.serializer.EnumValueSerializer())
+                .register(new io.papermc.paper.configuration.serializer.ComponentSerializer())
+        );
     }
 
-    protected abstract boolean isConfigType(final Type type);
+    protected boolean isConfigType(final Type type) {
+        return ConfigurationPart.class.isAssignableFrom(erase(type));
+    }
 
     protected ObjectMapper.Factory.Builder createGlobalObjectMapperFactoryBuilder() {
-        return this.createObjectMapper();
+        return defaultGlobalFactoryBuilder(this.createObjectMapper());
+    }
+
+    protected static ObjectMapper.Factory.Builder defaultGlobalFactoryBuilder(ObjectMapper.Factory.Builder builder) {
+        return builder.addDiscoverer(io.papermc.paper.configuration.mapping.InnerClassFieldDiscoverer.globalConfig());
     }
+    // Plazma end
 
     @MustBeInvokedByOverriders
     protected YamlConfigurationLoader.Builder createGlobalLoaderBuilder() {
@@ -88,7 +124,7 @@ public abstract class Configurations<G, W> {
         };
     }
 
-    static <T> CheckedFunction<ConfigurationNode, T, SerializationException> reloader(Class<T> type, T instance) {
+    public static <T> CheckedFunction<ConfigurationNode, T, SerializationException> reloader(Class<T> type, T instance) { // Plazma - package -> public
         return node -> {
             ObjectMapper.Factory factory = (ObjectMapper.Factory) Objects.requireNonNull(node.options().serializers().get(type));
             ObjectMapper.Mutable<T> mutable = (ObjectMapper.Mutable<T>) factory.get(type);
@@ -136,7 +172,8 @@ public abstract class Configurations<G, W> {
     protected ContextMap.Builder createDefaultContextMap() {
         return ContextMap.builder()
             .put(WORLD_NAME, WORLD_DEFAULTS)
-            .put(WORLD_KEY, WORLD_DEFAULTS_KEY);
+            .put(WORLD_KEY, WORLD_DEFAULTS_KEY) // Plazma - Moved from PaperConfigurations.java
+            .put(SPIGOT_WORLD_CONFIG_CONTEXT_KEY, SPIGOT_WORLD_DEFAULTS); // Plazma - Moved from PaperConfigurations.java
     }
 
     public void initializeWorldDefaultsConfiguration() throws ConfigurateException {
@@ -148,7 +185,7 @@ public abstract class Configurations<G, W> {
         final YamlConfigurationLoader loader = result.loader();
         final ConfigurationNode node = loader.load();
         if (result.isNewFile()) { // add version to new files
-            node.node(Configuration.VERSION_FIELD).raw(WorldConfiguration.CURRENT_VERSION);
+            node.node(Configuration.VERSION_FIELD).raw(getWorldConfigVersion()); // Plazma
         }
         this.applyWorldConfigTransformations(contextMap, node);
         final W instance = node.require(this.worldConfigClass);
@@ -174,7 +211,11 @@ public abstract class Configurations<G, W> {
     }
 
     protected ObjectMapper.Factory.Builder createWorldObjectMapperFactoryBuilder(final ContextMap contextMap) {
-        return this.createObjectMapper();
+        // Plazma start - Moved from PaperConfigurations.java
+        return this.createObjectMapper()
+                .addNodeResolver(new io.papermc.paper.configuration.legacy.RequiresSpigotInitialization.Factory(contextMap.require(SPIGOT_WORLD_CONFIG_CONTEXT_KEY).get()))
+                .addNodeResolver(new NestedSetting.Factory());
+        // Plazma end
     }
 
     @MustBeInvokedByOverriders
@@ -196,7 +237,7 @@ public abstract class Configurations<G, W> {
         final Path dir = contextMap.require(WORLD_DIRECTORY);
         final Path worldConfigFile = dir.resolve(this.worldConfigFileName);
         if (Files.notExists(worldConfigFile)) {
-            PaperConfigurations.createDirectoriesSymlinkAware(dir);
+            createDirectoriesSymlinkAware(dir); // Plazma
             Files.createFile(worldConfigFile); // create empty file as template
             newFile = true;
         }
@@ -207,7 +248,7 @@ public abstract class Configurations<G, W> {
             .build();
         final ConfigurationNode worldNode = worldLoader.load();
         if (newFile) { // set the version field if new file
-            worldNode.node(Configuration.VERSION_FIELD).set(WorldConfiguration.CURRENT_VERSION);
+            worldNode.node(Configuration.VERSION_FIELD).set(getWorldConfigVersion()); // Plazma
         }
         this.applyWorldConfigTransformations(contextMap, worldNode);
         this.applyDefaultsAwareWorldConfigTransformations(contextMap, worldNode, defaultsNode);
@@ -232,6 +273,40 @@ public abstract class Configurations<G, W> {
         return level.convertable.levelDirectory.path().resolve(this.worldConfigFileName);
     }
 
+    // Plazma start
+    @Deprecated
+    public org.bukkit.configuration.file.YamlConfiguration createLegacyObject(final net.minecraft.server.MinecraftServer server) {
+        org.bukkit.configuration.file.YamlConfiguration global = org.bukkit.configuration.file.YamlConfiguration.loadConfiguration(this.globalFolder.resolve(this.globalConfigFileName).toFile());
+        org.bukkit.configuration.ConfigurationSection worlds = global.createSection("__________WORLDS__________");
+        worlds.set("__defaults__", org.bukkit.configuration.file.YamlConfiguration.loadConfiguration(this.globalFolder.resolve(this.defaultWorldConfigFileName).toFile()));
+        for (ServerLevel level : server.getAllLevels())
+            worlds.set(level.getWorld().getName(), org.bukkit.configuration.file.YamlConfiguration.loadConfiguration(getWorldConfigFile(level).toFile()));
+        return global;
+    }
+
+    // Symlinks are not correctly checked in createDirectories
+    protected static void createDirectoriesSymlinkAware(Path path) throws IOException {
+        if (!Files.isDirectory(path)) {
+            Files.createDirectories(path);
+        }
+    }
+
+    protected static ContextMap createWorldContextMap(ServerLevel level) {
+        return createWorldContextMap(level.convertable.levelDirectory.path(), level.serverLevelData.getLevelName(), level.dimension().location(), level.spigotConfig);
+    }
+
+    public static ContextMap createWorldContextMap(Path dir, String levelName, ResourceLocation worldKey, SpigotWorldConfig spigotConfig) {
+        return ContextMap.builder()
+                .put(WORLD_DIRECTORY, dir)
+                .put(WORLD_NAME, levelName)
+                .put(WORLD_KEY, worldKey)
+                .put(SPIGOT_WORLD_CONFIG_CONTEXT_KEY, Suppliers.ofInstance(spigotConfig))
+                .build();
+    }
+
+    protected abstract int getWorldConfigVersion();
+    // Plazma end
+
     public static class ContextMap {
         private static final Object VOID = new Object();
 
diff --git a/src/main/java/io/papermc/paper/configuration/PaperConfigurations.java b/src/main/java/io/papermc/paper/configuration/PaperConfigurations.java
index 9e8b8de907654050c51400286af971caca87d6bd..4b0b36da8eef7fa1fbd1d4abced618c8f1dab9a9 100644
--- a/src/main/java/io/papermc/paper/configuration/PaperConfigurations.java
+++ b/src/main/java/io/papermc/paper/configuration/PaperConfigurations.java
@@ -77,7 +77,6 @@ public class PaperConfigurations extends Configurations<GlobalConfiguration, Wor
     static final String GLOBAL_CONFIG_FILE_NAME = "paper-global.yml";
     static final String WORLD_DEFAULTS_CONFIG_FILE_NAME = "paper-world-defaults.yml";
     static final String WORLD_CONFIG_FILE_NAME = "paper-world.yml";
-    public static final String CONFIG_DIR = "config";
     private static final String BACKUP_DIR ="legacy-backup";
 
     private static final String GLOBAL_HEADER = String.format("""
@@ -129,20 +128,12 @@ public class PaperConfigurations extends Configurations<GlobalConfiguration, Wor
         See https://docs.papermc.io/paper/configuration for more information.
         """;
 
-    @VisibleForTesting
-    public static final Supplier<SpigotWorldConfig> SPIGOT_WORLD_DEFAULTS = Suppliers.memoize(() -> new SpigotWorldConfig(RandomStringUtils.randomAlphabetic(255)) {
-        @Override // override to ensure "verbose" is false
-        public void init() {
-            SpigotConfig.readConfig(SpigotWorldConfig.class, this);
-        }
-    });
-    public static final ContextKey<Supplier<SpigotWorldConfig>> SPIGOT_WORLD_CONFIG_CONTEXT_KEY = new ContextKey<>(new TypeToken<Supplier<SpigotWorldConfig>>() {}, "spigot world config");
-
 
     public PaperConfigurations(final Path globalFolder) {
         super(globalFolder, GlobalConfiguration.class, WorldConfiguration.class, GLOBAL_CONFIG_FILE_NAME, WORLD_DEFAULTS_CONFIG_FILE_NAME, WORLD_CONFIG_FILE_NAME);
     }
 
+    /* // Plazma - Moved to Configurations.java
     @Override
     protected YamlConfigurationLoader.Builder createLoaderBuilder() {
         return super.createLoaderBuilder()
@@ -165,6 +156,7 @@ public class PaperConfigurations extends Configurations<GlobalConfiguration, Wor
     private static ObjectMapper.Factory.Builder defaultGlobalFactoryBuilder(ObjectMapper.Factory.Builder builder) {
         return builder.addDiscoverer(InnerClassFieldDiscoverer.globalConfig());
     }
+     */ // Plazma
 
     @Override
     protected YamlConfigurationLoader.Builder createGlobalLoaderBuilder() {
@@ -188,17 +180,17 @@ public class PaperConfigurations extends Configurations<GlobalConfiguration, Wor
         return configuration;
     }
 
+    /* // Plazma - Moved to Configurations.java
     @Override
     protected ContextMap.Builder createDefaultContextMap() {
         return super.createDefaultContextMap()
             .put(SPIGOT_WORLD_CONFIG_CONTEXT_KEY, SPIGOT_WORLD_DEFAULTS);
     }
+     */ // Plazma
 
     @Override
     protected ObjectMapper.Factory.Builder createWorldObjectMapperFactoryBuilder(final ContextMap contextMap) {
         return super.createWorldObjectMapperFactoryBuilder(contextMap)
-            .addNodeResolver(new RequiresSpigotInitialization.Factory(contextMap.require(SPIGOT_WORLD_CONFIG_CONTEXT_KEY).get()))
-            .addNodeResolver(new NestedSetting.Factory())
             .addDiscoverer(InnerClassFieldDiscoverer.worldConfig(createWorldConfigInstance(contextMap)));
     }
 
@@ -298,10 +290,12 @@ public class PaperConfigurations extends Configurations<GlobalConfiguration, Wor
         }
     }
 
+    /* // Plazma - Moved to Configurations.java
     @Override
     protected boolean isConfigType(final Type type) {
         return ConfigurationPart.class.isAssignableFrom(erase(type));
     }
+     */ // Plazma
 
     public void reloadConfigs(MinecraftServer server) {
         try {
@@ -315,19 +309,6 @@ public class PaperConfigurations extends Configurations<GlobalConfiguration, Wor
         }
     }
 
-    private static ContextMap createWorldContextMap(ServerLevel level) {
-        return createWorldContextMap(level.convertable.levelDirectory.path(), level.serverLevelData.getLevelName(), level.dimension().location(), level.spigotConfig);
-    }
-
-    public static ContextMap createWorldContextMap(Path dir, String levelName, ResourceLocation worldKey, SpigotWorldConfig spigotConfig) {
-        return ContextMap.builder()
-            .put(WORLD_DIRECTORY, dir)
-            .put(WORLD_NAME, levelName)
-            .put(WORLD_KEY, worldKey)
-            .put(SPIGOT_WORLD_CONFIG_CONTEXT_KEY, Suppliers.ofInstance(spigotConfig))
-            .build();
-    }
-
     public static PaperConfigurations setup(final Path legacyConfig, final Path configDir, final Path worldFolder, final File spigotConfig) throws Exception {
         final Path legacy = Files.isSymbolicLink(legacyConfig) ? Files.readSymbolicLink(legacyConfig) : legacyConfig;
         if (needsConverting(legacyConfig)) {
@@ -416,17 +397,6 @@ public class PaperConfigurations extends Configurations<GlobalConfiguration, Wor
         return Files.exists(legacyConfig) && Files.isRegularFile(legacyConfig);
     }
 
-    @Deprecated
-    public YamlConfiguration createLegacyObject(final MinecraftServer server) {
-        YamlConfiguration global = YamlConfiguration.loadConfiguration(this.globalFolder.resolve(this.globalConfigFileName).toFile());
-        ConfigurationSection worlds = global.createSection("__________WORLDS__________");
-        worlds.set("__defaults__", YamlConfiguration.loadConfiguration(this.globalFolder.resolve(this.defaultWorldConfigFileName).toFile()));
-        for (ServerLevel level : server.getAllLevels()) {
-            worlds.set(level.getWorld().getName(), YamlConfiguration.loadConfiguration(getWorldConfigFile(level).toFile()));
-        }
-        return global;
-    }
-
     @Deprecated
     public static YamlConfiguration loadLegacyConfigFile(File configFile) throws Exception {
         YamlConfiguration config = new YamlConfiguration();
@@ -448,10 +418,10 @@ public class PaperConfigurations extends Configurations<GlobalConfiguration, Wor
         return BasicConfigurationNode.root(options);
     }
 
-    // Symlinks are not correctly checked in createDirectories
-    static void createDirectoriesSymlinkAware(Path path) throws IOException {
-        if (!Files.isDirectory(path)) {
-            Files.createDirectories(path);
-        }
+    // Plazma start
+    @Override
+    protected int getWorldConfigVersion() {
+        return WorldConfiguration.CURRENT_VERSION;
     }
+    // Plazma end
 }
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index b4d5bca6e3a39186a988098fb5d4cae97a776e79..8e5492bbdddb199bee021d79769ed2ee051128cf 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -301,6 +301,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public final double[] recentTps = new double[ 4 ]; // Purpur
     // Spigot end
     public final io.papermc.paper.configuration.PaperConfigurations paperConfigurations;
+    public final org.plazmamc.plazma.configurations.PlazmaConfigurations plazmaConfigurations; // Plazma
     public static long currentTickLong = 0L; // Paper
     public boolean lagging = false; // Purpur
     protected boolean upnp = false; // Purpur
@@ -410,6 +411,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         Runtime.getRuntime().addShutdownHook(new org.bukkit.craftbukkit.util.ServerShutdownThread(this));
         // CraftBukkit end
         this.paperConfigurations = services.paperConfigurations(); // Paper
+        this.plazmaConfigurations = services.plazmaConfigurations(); // Plazma
     }
 
     private void readScoreboard(DimensionDataStorage persistentStateManager) {
diff --git a/src/main/java/net/minecraft/server/Services.java b/src/main/java/net/minecraft/server/Services.java
index a9b2c8cd4dcd3f884e4306bebee9334d3848fce5..261f61904d84455061af8d367b12903c7251a5cb 100644
--- a/src/main/java/net/minecraft/server/Services.java
+++ b/src/main/java/net/minecraft/server/Services.java
@@ -11,12 +11,19 @@ import net.minecraft.server.players.GameProfileCache;
 import net.minecraft.util.SignatureValidator;
 
 // Paper start
-public record Services(MinecraftSessionService sessionService, ServicesKeySet servicesKeySet, GameProfileRepository profileRepository, GameProfileCache profileCache, @javax.annotation.Nullable io.papermc.paper.configuration.PaperConfigurations paperConfigurations) {
+public record Services(MinecraftSessionService sessionService, ServicesKeySet servicesKeySet, GameProfileRepository profileRepository, GameProfileCache profileCache, @javax.annotation.Nullable io.papermc.paper.configuration.PaperConfigurations paperConfigurations, @org.jetbrains.annotations.Nullable org.plazmamc.plazma.configurations.PlazmaConfigurations plazmaConfigurations) { // Plazma
 
     public Services(MinecraftSessionService sessionService, ServicesKeySet servicesKeySet, GameProfileRepository profileRepository, GameProfileCache profileCache) {
-        this(sessionService, servicesKeySet, profileRepository, profileCache, null);
+        this(sessionService, servicesKeySet, profileRepository, profileCache, null, null); // Plazma
     }
 
+    // Plazma start
+    @Override
+    public org.plazmamc.plazma.configurations.PlazmaConfigurations plazmaConfigurations() {
+        return java.util.Objects.requireNonNull(this.plazmaConfigurations);
+    }
+    // Plazma end
+
     @Override
     public io.papermc.paper.configuration.PaperConfigurations paperConfigurations() {
         return java.util.Objects.requireNonNull(this.paperConfigurations);
@@ -32,7 +39,11 @@ public record Services(MinecraftSessionService sessionService, ServicesKeySet se
         final java.nio.file.Path legacyConfigPath = ((File) optionSet.valueOf("paper-settings")).toPath();
         final java.nio.file.Path configDirPath = ((File) optionSet.valueOf("paper-settings-directory")).toPath();
         io.papermc.paper.configuration.PaperConfigurations paperConfigurations = io.papermc.paper.configuration.PaperConfigurations.setup(legacyConfigPath, configDirPath, rootDirectory.toPath(), (File) optionSet.valueOf("spigot-settings"));
-        return new Services(minecraftSessionService, authenticationService.getServicesKeySet(), gameProfileRepository, gameProfileCache, paperConfigurations);
+        // Plazma start
+        final java.nio.file.Path plazmaConfigDirPath = ((File) optionSet.valueOf("plazma-settings-directory")).toPath();
+        org.plazmamc.plazma.configurations.PlazmaConfigurations plazmaConfigurations = org.plazmamc.plazma.configurations.PlazmaConfigurations.setup(plazmaConfigDirPath);
+        return new Services(minecraftSessionService, authenticationService.getServicesKeySet(), gameProfileRepository, gameProfileCache, paperConfigurations, plazmaConfigurations);
+        // Plazma end
         // Paper end
     }
 
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index a51306bb36d403ab627cd8b2fc8d8f7a3e6ca918..8f5d6e2399b918f037f3637ff408b8f7b91af677 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -209,6 +209,8 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         io.papermc.paper.util.ObfHelper.INSTANCE.getClass(); // Paper - load mappings for stacktrace deobf and etc.
         paperConfigurations.initializeGlobalConfiguration();
         paperConfigurations.initializeWorldDefaultsConfiguration();
+        plazmaConfigurations.initializeGlobalConfiguration(); // Plazma
+        plazmaConfigurations.initializeWorldDefaultsConfiguration(); // Plazma
         // Paper start - moved up to right after PlayerList creation but before file load/save
         if (this.convertOldUsers()) {
             this.getProfileCache().save(false); // Paper
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 36a1ac09bec7b4139d1cd44e6ecda72fc30fa8c4..af4eb54d99b67d059534e5e55e952aa41bb87bc7 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -175,6 +175,12 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     }
     // Paper end
 
+    // Plazma start
+    private final org.plazmamc.plazma.configurations.WorldConfigurations plazmaConfig;
+    public org.plazmamc.plazma.configurations.WorldConfigurations plazmaConfig() {
+        return this.plazmaConfig;
+    }
+    // Plazma end
     public final com.destroystokyo.paper.antixray.ChunkPacketBlockController chunkPacketBlockController; // Paper - Anti-Xray
     public final org.purpurmc.purpur.PurpurWorldConfig purpurConfig; // Purpur
     public final co.aikar.timings.WorldTimingsHandler timings; // Paper
@@ -256,9 +262,10 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
 
     //protected final io.papermc.paper.util.math.ThreadUnsafeRandom randomTickRandom = new io.papermc.paper.util.math.ThreadUnsafeRandom(java.util.concurrent.ThreadLocalRandom.current().nextLong()); public net.minecraft.util.RandomSource getThreadUnsafeRandom() { return this.randomTickRandom; } // Pufferfish - move thread unsafe random initialization // Pufferfish - getter // Purpur - dont break ABI
 
-    protected Level(WritableLevelData worlddatamutable, ResourceKey<Level> resourcekey, RegistryAccess iregistrycustom, Holder<DimensionType> holder, Supplier<ProfilerFiller> supplier, boolean flag, boolean flag1, long i, int j, org.bukkit.generator.ChunkGenerator gen, org.bukkit.generator.BiomeProvider biomeProvider, org.bukkit.World.Environment env, java.util.function.Function<org.spigotmc.SpigotWorldConfig, io.papermc.paper.configuration.WorldConfiguration> paperWorldConfigCreator, java.util.concurrent.Executor executor) { // Paper - Async-Anti-Xray - Pass executor
+    protected Level(WritableLevelData worlddatamutable, ResourceKey<Level> resourcekey, RegistryAccess iregistrycustom, Holder<DimensionType> holder, Supplier<ProfilerFiller> supplier, boolean flag, boolean flag1, long i, int j, org.bukkit.generator.ChunkGenerator gen, org.bukkit.generator.BiomeProvider biomeProvider, org.bukkit.World.Environment env, java.util.function.Function<org.spigotmc.SpigotWorldConfig, io.papermc.paper.configuration.WorldConfiguration> paperWorldConfigCreator, java.util.function.Function<org.spigotmc.SpigotWorldConfig, org.plazmamc.plazma.configurations.WorldConfigurations> plazmaWorldConfigurationCreator, java.util.concurrent.Executor executor) { // Paper - Async-Anti-Xray - Pass executor // Plazma
         this.spigotConfig = new org.spigotmc.SpigotWorldConfig(((net.minecraft.world.level.storage.PrimaryLevelData) worlddatamutable).getLevelName()); // Spigot
         this.paperConfig = paperWorldConfigCreator.apply(this.spigotConfig); // Paper
+        this.plazmaConfig = plazmaWorldConfigurationCreator.apply(this.spigotConfig); // Plazma
         this.purpurConfig = new org.purpurmc.purpur.PurpurWorldConfig(((net.minecraft.world.level.storage.PrimaryLevelData) worlddatamutable).getLevelName(), env); // Purpur
         this.playerBreedingCooldowns = this.getNewBreedingCooldownCache(); // Purpur
         this.generator = gen;
diff --git a/src/main/java/org/plazmamc/plazma/configurations/ChangedConfigurations.java b/src/main/java/org/plazmamc/plazma/configurations/ChangedConfigurations.java
new file mode 100644
index 0000000000000000000000000000000000000000..517ae4097a484c90c5225d7e6b41911e53396604
--- /dev/null
+++ b/src/main/java/org/plazmamc/plazma/configurations/ChangedConfigurations.java
@@ -0,0 +1,16 @@
+package org.plazmamc.plazma.configurations;
+
+import org.spongepowered.configurate.NodePath;
+
+import java.util.HashMap;
+import java.util.Map;
+
+interface ChangedConfigurations {
+
+    Map<NodePath, String> MOVED_WORLD_PATH = new HashMap<>() {{}};
+    NodePath[] REMOVED_WORLD_PATHS = {};
+
+    Map<NodePath, String> MOVED_GLOBAL_PATH = new HashMap<>() {{}};
+    NodePath[] REMOVED_GLOBAL_PATH = {};
+
+}
diff --git a/src/main/java/org/plazmamc/plazma/configurations/GlobalConfiguration.java b/src/main/java/org/plazmamc/plazma/configurations/GlobalConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..2ab5738a34800b8f13c78b805b44362ea61add7f
--- /dev/null
+++ b/src/main/java/org/plazmamc/plazma/configurations/GlobalConfiguration.java
@@ -0,0 +1,28 @@
+package org.plazmamc.plazma.configurations;
+
+import io.papermc.paper.configuration.Configuration;
+import io.papermc.paper.configuration.ConfigurationPart;
+import org.jetbrains.annotations.NotNull;
+import org.spongepowered.configurate.objectmapping.meta.Setting;
+
+public class GlobalConfiguration extends ConfigurationPart {
+
+    private static final int VERSION = 2;
+    private static final boolean OPTIMIZE = false;
+    private static GlobalConfiguration INSTANCE;
+
+    public static GlobalConfiguration get() {
+        return INSTANCE;
+    }
+
+    static void set(@NotNull GlobalConfiguration instance, boolean test) {
+        GlobalConfiguration.INSTANCE = instance;
+        if (test) {
+
+        }
+    }
+
+    @Setting(Configuration.VERSION_FIELD)
+    int version = VERSION;
+
+}
diff --git a/src/main/java/org/plazmamc/plazma/configurations/PlazmaConfigurations.java b/src/main/java/org/plazmamc/plazma/configurations/PlazmaConfigurations.java
new file mode 100644
index 0000000000000000000000000000000000000000..7b74abea851541e46d25b2317c0ffaeadd10ded4
--- /dev/null
+++ b/src/main/java/org/plazmamc/plazma/configurations/PlazmaConfigurations.java
@@ -0,0 +1,271 @@
+package org.plazmamc.plazma.configurations;
+
+import com.mojang.logging.LogUtils;
+import io.leangen.geantyref.TypeToken;
+import io.papermc.paper.configuration.Configuration;
+import io.papermc.paper.configuration.ConfigurationPart;
+import io.papermc.paper.configuration.Configurations;
+import io.papermc.paper.configuration.mapping.InnerClassFieldDiscoverer;
+import io.papermc.paper.configuration.serializer.NbtPathSerializer;
+import io.papermc.paper.configuration.serializer.PacketClassSerializer;
+import io.papermc.paper.configuration.serializer.StringRepresentableSerializer;
+import io.papermc.paper.configuration.serializer.collections.FastutilMapSerializer;
+import io.papermc.paper.configuration.serializer.collections.TableSerializer;
+import io.papermc.paper.configuration.serializer.registry.RegistryHolderSerializer;
+import io.papermc.paper.configuration.serializer.registry.RegistryValueSerializer;
+import io.papermc.paper.configuration.type.BooleanOrDefault;
+import io.papermc.paper.configuration.type.Duration;
+import io.papermc.paper.configuration.type.DurationOrDisabled;
+import io.papermc.paper.configuration.type.EngineMode;
+import io.papermc.paper.configuration.type.fallback.FallbackValueSerializer;
+import io.papermc.paper.configuration.type.number.DoubleOr;
+import io.papermc.paper.configuration.type.number.IntOr;
+import it.unimi.dsi.fastutil.objects.Reference2IntMap;
+import it.unimi.dsi.fastutil.objects.Reference2IntOpenHashMap;
+import it.unimi.dsi.fastutil.objects.Reference2LongMap;
+import it.unimi.dsi.fastutil.objects.Reference2LongOpenHashMap;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.item.Item;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.VisibleForTesting;
+import org.slf4j.Logger;
+import org.spongepowered.configurate.*;
+import org.spongepowered.configurate.objectmapping.FieldDiscoverer;
+import org.spongepowered.configurate.objectmapping.ObjectMapper;
+import org.spongepowered.configurate.transformation.ConfigurationTransformation;
+import org.spongepowered.configurate.transformation.TransformAction;
+import org.spongepowered.configurate.yaml.YamlConfigurationLoader;
+
+import java.io.IOException;
+import java.nio.file.Path;
+import java.util.Map;
+import java.util.function.Function;
+
+import static io.leangen.geantyref.GenericTypeReflector.erase;
+
+public class PlazmaConfigurations extends Configurations<GlobalConfiguration, WorldConfigurations> {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+    static final String GLOBAL_CONFIG_FILE_NAME = "plazma-global.yml";
+    static final String WORLD_DEFAULTS_CONFIG_FILE_NAME = "plazma-world-defaults.yml";
+    static final String WORLD_CONFIG_FILE_NAME = "plazma-world.yml";
+    static final boolean OPTIMIZE = !Boolean.getBoolean("Plazma.disableConfigOptimization");
+
+    private static final String HEADER_START = """
+            #### ENGLISH ####
+            This is the %s configuration file for Plazma.
+            As you can see, there's a lot to configure. Some options may impact gameplay,
+            so use with caution, and make sure you know what each option does before configuring.
+            
+            A description of the options can be found on the official wiki,
+            If you need help with the configuration or have any questions related to Plazma,
+            join us in our Discord for Plazma, or create issues on our GitHub repository.
+            
+            %s
+            
+            #### 한국어 ####
+            본 파일은 Plazma의 %s 설정 파일입니다.
+            보시다시피, 굉장히 많은 설정이 있습니다. 일부 설정은 게임 플레이에 영향을 줄 수 있습니다.
+            따라서 주의해서 사용하시고, 각 설정이 서버에 어떠한 작용을 하는지 숙지하고 사용하시기 바랍니다.
+            
+            구성에 대한 설명은 공식 위키에서 찾을 수 있으며,
+            만약 설정에 도움이 필요하거나, Plazma에 대 질문이 있으시다면,
+            공식 Discord 서버에 접속하거나, GitHub 레포지토리에 이슈를 생성해주시기 바랍니다.
+            
+            %s
+            
+            GitHub: https://github.com/PlazmaMC/Plazma
+            Wiki: https://github.com/PlazmaMC/Plazma/wiki
+            Discord: https://plazmamc.org/discord
+            """;
+
+    private static final String GLOBAL_HEADER = String.format(HEADER_START,
+            "global", String.format("World options can be set in the %s file.", WORLD_DEFAULTS_CONFIG_FILE_NAME),
+            "전역", String.format("월드별 설정은 %s 파일에서 설정할 수 있습니다.", WORLD_DEFAULTS_CONFIG_FILE_NAME)
+    );
+
+    private static final String WORLD_DEFAULTS_HEADER = String.format(HEADER_START,
+            "world default", String.format("""
+                    World-specific settings can be set in the %s file within each world folder,
+                    and the same settings apply to all worlds unless they are overwritten
+                    through the world-specific settings file.
+                    """, WORLD_CONFIG_FILE_NAME),
+            "월드 기본", String.format("""
+                    월드별 설정은 각 월드 폴더 내 %s 파일에서 설정할 수 있으며, 월드별 설정을 통해 값을
+                    덮어쓰지 않는 한, 모든 월드에 동일한 설정이 적용됩니다.
+                    """, WORLD_CONFIG_FILE_NAME)
+    );
+
+    private static final Function<ContextMap, String> WORLD_HEADER = map -> String.format("""
+            #### ENGLISH ####
+            This is world-specific Plazma configuration file for the world %s (%s).
+            This file may start empty, but can be filled with options to override world default configuration.
+            Some options may impact gameplay, so use with caution,
+            and make sure you know what each option does before configuring.
+            
+            A description of the options can be found on the official wiki,
+            If you need help with the configuration or have any questions related to Plazma,
+            join us in our Discord for Plazma, or create issues on our GitHub repository.
+            
+            
+            #### 한국어 ####
+            본 파일은 %s (%s) 월드 전용 Plazma 월드별 설정 파일입니다.
+            이 파일은 비어있을 수 있지만, 월드 기본 설정을 덮어쓰기 위해 옵션을 추가할 수 있습니다.
+            일부 설정은 게임 플레이에 영향을 줄 수 있으므로, 주의해서 사용하시고,
+            각 설정이 서버에 어떠한 작용을 하는지 숙지하고 사용하시기 바랍니다.
+            
+            구성에 대한 설명은 공식 위키에서 찾을 수 있으며,
+            만약 설정에 도움이 필요하거나, Plazma에 대 질문이 있으시다면,
+            공식 Discord 서버에 접속하거나, GitHub 레포지토리에 이슈를 생성해주시기 바랍니다.
+            
+            
+            World Default Config Directory: %s/%s
+            GitHub: https://github.com/PlazmaMC/Plazma
+            Wiki: https://github.com/PlazmaMC/Plazma/wiki
+            Discord: https://plazmamc.org/discord
+            """, map.require(WORLD_NAME), map.require(WORLD_KEY), map.require(WORLD_NAME), map.require(WORLD_KEY),
+            CONFIG_DIR, WORLD_DEFAULTS_CONFIG_FILE_NAME);
+
+    public PlazmaConfigurations(final Path globalFolder) {
+        super(globalFolder, GlobalConfiguration.class, WorldConfigurations.class, GLOBAL_CONFIG_FILE_NAME, WORLD_DEFAULTS_CONFIG_FILE_NAME, WORLD_CONFIG_FILE_NAME);
+    }
+
+    private static ConfigurationOptions defaultGlobalOptions(ConfigurationOptions options) {
+        return options.header(GLOBAL_HEADER).serializers(builder -> builder
+                .register(new PacketClassSerializer())
+                .register(IntOr.Default.SERIALIZER)
+        );
+    }
+
+    @Override
+    protected YamlConfigurationLoader.@NotNull Builder createGlobalLoaderBuilder() {
+        return super.createGlobalLoaderBuilder().defaultOptions(PlazmaConfigurations::defaultGlobalOptions);
+    }
+
+    @Override
+    public GlobalConfiguration initializeGlobalConfiguration() throws ConfigurateException {
+        GlobalConfiguration configuration = super.initializeGlobalConfiguration();
+        GlobalConfiguration.set(configuration, false);
+        return configuration;
+    }
+
+    @Override
+    protected void applyGlobalConfigTransformations(final @NotNull ConfigurationNode node) throws ConfigurateException {
+        ConfigurationTransformation.Builder builder = ConfigurationTransformation.builder();
+
+        for (NodePath path : ChangedConfigurations.REMOVED_GLOBAL_PATH)
+            builder.addAction(path, TransformAction.remove());
+
+        ChangedConfigurations.MOVED_GLOBAL_PATH.forEach((oldPath, newPath) ->
+                builder.addAction(oldPath, TransformAction.rename(newPath)));
+
+        builder.build().apply(node);
+    }
+
+    private static FieldDiscoverer<?> worldConfigDiscoverer(final ContextMap contextMap) {
+        final Map<Class<?>, Object> overrides = Map.of(
+                WorldConfigurations.class, new WorldConfigurations(contextMap.require(WORLD_KEY))
+        );
+        return new InnerClassFieldDiscoverer(overrides);
+    }
+
+    @Override
+    protected ObjectMapper.Factory.@NotNull Builder createWorldObjectMapperFactoryBuilder(final @NotNull ContextMap contextMap) {
+        return super.createWorldObjectMapperFactoryBuilder(contextMap).addDiscoverer(worldConfigDiscoverer(contextMap));
+    }
+
+    @Override
+    protected YamlConfigurationLoader.@NotNull Builder createWorldConfigLoaderBuilder(final @NotNull ContextMap contextMap) {
+        return super.createWorldConfigLoaderBuilder(contextMap)
+                .defaultOptions(options -> options
+                        .header(contextMap.require(WORLD_NAME).equals(WORLD_DEFAULTS) ? WORLD_DEFAULTS_HEADER : WORLD_HEADER.apply(contextMap))
+                        .serializers(serializers -> serializers
+                                .register(new TypeToken<>() {}, new FastutilMapSerializer.SomethingToPrimitive<@NotNull Reference2IntMap<?>>(Reference2IntOpenHashMap::new, Integer.TYPE))
+                                .register(new TypeToken<>() {}, new FastutilMapSerializer.SomethingToPrimitive<@NotNull Reference2LongMap<?>>(Reference2LongOpenHashMap::new, Long.TYPE))
+                                .register(new TypeToken<>() {}, new TableSerializer())
+                                .register(StringRepresentableSerializer::isValidFor, new StringRepresentableSerializer())
+                                .register(IntOr.Default.SERIALIZER)
+                                .register(IntOr.Disabled.SERIALIZER)
+                                .register(DoubleOr.Default.SERIALIZER)
+                                .register(BooleanOrDefault.SERIALIZER)
+                                .register(Duration.SERIALIZER)
+                                .register(DurationOrDisabled.SERIALIZER)
+                                .register(EngineMode.SERIALIZER)
+                                .register(NbtPathSerializer.SERIALIZER)
+                                .register(FallbackValueSerializer.create(contextMap.require(SPIGOT_WORLD_CONFIG_CONTEXT_KEY).get(), MinecraftServer::getServer))
+                                .register(new RegistryValueSerializer<>(new TypeToken<>() {}, Registries.ENTITY_TYPE, true))
+                                .register(new RegistryValueSerializer<>(Item.class, Registries.ITEM, true))
+                                .register(new RegistryHolderSerializer<>(new TypeToken<>() {}, Registries.CONFIGURED_FEATURE, false))
+                                .register(new RegistryHolderSerializer<>(Item.class, Registries.ITEM, true))
+                        )
+                );
+    }
+
+    @Override
+    public WorldConfigurations createWorldConfig(final @NotNull ContextMap contextMap) {
+        final String levelName = contextMap.require(WORLD_NAME);
+        try {
+            return super.createWorldConfig(contextMap);
+        } catch (IOException exception) {
+            throw new RuntimeException("Could not create world configuration for " + levelName, exception);
+        }
+    }
+
+    @Override
+    protected void applyWorldConfigTransformations(final @NotNull ContextMap contextMap, final @NotNull ConfigurationNode node) throws ConfigurateException {
+        final ConfigurationNode version = node.node(Configuration.VERSION_FIELD);
+        final String world = contextMap.require(WORLD_NAME);
+        ConfigurationTransformation.Builder builder = ConfigurationTransformation.builder();
+
+        if (version.virtual()) {
+            LOGGER.warn("The world configuration file for " + world + " didn't have a version set, assuming latest");
+            version.raw(WorldConfigurations.VERSION);
+        }
+
+        for (NodePath path : ChangedConfigurations.REMOVED_WORLD_PATHS)
+            builder.addAction(path, TransformAction.remove());
+
+        ChangedConfigurations.MOVED_WORLD_PATH.forEach((oldPath, newPath) ->
+                builder.addAction(oldPath, TransformAction.rename(newPath)));
+
+        builder.build().apply(node);
+    }
+
+    public static PlazmaConfigurations setup(final Path configDir) {
+        try {
+            createDirectoriesSymlinkAware(configDir);
+            return new PlazmaConfigurations(configDir);
+        } catch (IOException e) {
+            throw new RuntimeException("Could not setup Plazma configuration files", e);
+        }
+    }
+
+    public void reloadConfigs(MinecraftServer server) {
+        try {
+            this.initializeGlobalConfiguration(reloader(this.globalConfigClass, GlobalConfiguration.get()));
+            this.initializeWorldDefaultsConfiguration();
+            //server.getAllLevels().forEach(level -> this.createWorldConfig(createWorldContextMap(level), reloader(this.worldConfigClass, level.plazmaConfig()))); // TODO
+        } catch (Exception e) {
+            throw new RuntimeException("Could not reload Plazma configuration files", e);
+        }
+    }
+
+    @VisibleForTesting
+    static ConfigurationNode createForTesting() {
+        ObjectMapper.Factory factory = defaultGlobalFactoryBuilder(ObjectMapper.factoryBuilder()).build();
+        ConfigurationOptions options = defaultGlobalOptions(defaultOptions(ConfigurationOptions.defaults()))
+                .serializers(builder -> builder.register(type -> ConfigurationPart.class.isAssignableFrom(erase(type)), factory.asTypeSerializer()));
+        return BasicConfigurationNode.root(options);
+    }
+
+    @Override
+    protected int getWorldConfigVersion() {
+        return WorldConfigurations.VERSION;
+    }
+
+    public static boolean optimize() {
+        return OPTIMIZE;
+    }
+
+}
diff --git a/src/main/java/org/plazmamc/plazma/configurations/WorldConfigurations.java b/src/main/java/org/plazmamc/plazma/configurations/WorldConfigurations.java
new file mode 100644
index 0000000000000000000000000000000000000000..9fb7f4cee90956b6e925fbad6285facfbfb143cd
--- /dev/null
+++ b/src/main/java/org/plazmamc/plazma/configurations/WorldConfigurations.java
@@ -0,0 +1,16 @@
+package org.plazmamc.plazma.configurations;
+
+import io.papermc.paper.configuration.ConfigurationPart;
+import net.minecraft.resources.ResourceLocation;
+
+public class WorldConfigurations extends ConfigurationPart {
+    private static final boolean OPTIMIZE = false; // TODO
+    static final int VERSION = 2;
+
+    private transient final ResourceLocation worldKey;
+    public WorldConfigurations(ResourceLocation worldKey) {
+        this.worldKey = worldKey;
+    }
+
+
+}
