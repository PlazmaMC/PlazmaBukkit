From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: AlphaKR93 <dev@alpha93.kr>
Date: Sat, 26 Oct 2024 13:42:26 +0900
Subject: [PATCH] Implement alternative noise chunk generator

Based on Steveplays28/noisium.
Copyright (C) 2024 Darion Spaargaren, Licensed under GPL v3.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
index e4ae25c83ab9dd1aaa530a5456275ef63cdb8511..03a5effa6f0ef4d5c46a03a39cf336493873cfea 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
@@ -19,9 +19,9 @@ public class LevelChunkSection implements ca.spottedleaf.moonrise.patches.block_
     public static final int SECTION_HEIGHT = 16;
     public static final int SECTION_SIZE = 4096;
     public static final int BIOME_CONTAINER_BITS = 2;
-    short nonEmptyBlockCount; // Paper - package private
-    private short tickingBlockCount;
-    private short tickingFluidCount;
+    public short nonEmptyBlockCount; // Paper - package private // Plazma -> public
+    public short tickingBlockCount; // Plazma - private -> public
+    public short tickingFluidCount; // Plazma - private -> public
     public final PalettedContainer<BlockState> states;
     private PalettedContainer<Holder<Biome>> biomes; // CraftBukkit - read/write
 
@@ -35,8 +35,8 @@ public class LevelChunkSection implements ca.spottedleaf.moonrise.patches.block_
 
     private boolean isClient;
     private static final short CLIENT_FORCED_SPECIAL_COLLIDING_BLOCKS = (short)9999;
-    private short specialCollidingBlocks;
-    private final ca.spottedleaf.moonrise.common.list.ShortList tickingBlocks = new ca.spottedleaf.moonrise.common.list.ShortList();
+    public short specialCollidingBlocks; // Plazma - private -> public
+    public final ca.spottedleaf.moonrise.common.list.ShortList tickingBlocks = new ca.spottedleaf.moonrise.common.list.ShortList(); // Plazma - private -> public
 
     @Override
     public final boolean moonrise$hasSpecialCollidingBlocks() {
@@ -309,18 +309,14 @@ public class LevelChunkSection implements ca.spottedleaf.moonrise.patches.block_
     // CraftBukkit end
 
     public void fillBiomesFromNoise(BiomeResolver biomeSupplier, Climate.Sampler sampler, int x, int y, int z) {
-        PalettedContainer<Holder<Biome>> datapaletteblock = this.biomes.recreate();
-        boolean flag = true;
+        // Plazma start - Optimize noise
+        PalettedContainer<Holder<Biome>> block = this.biomes.recreate();
 
-        for (int l = 0; l < 4; ++l) {
-            for (int i1 = 0; i1 < 4; ++i1) {
-                for (int j1 = 0; j1 < 4; ++j1) {
-                    datapaletteblock.getAndSetUnchecked(l, i1, j1, biomeSupplier.getNoiseBiome(x + l, y + i1, z + j1, sampler));
-                }
-            }
-        }
+        for (int dY = 0; dY < 4; ++dY) for (int dZ = 0; dZ < 4; ++dZ) for (int dX = 0; dX < 4; ++dX)
+            block.getAndSetUnchecked(dX, dY, dZ, biomeSupplier.getNoiseBiome(x + dX, y + dY, z + dZ, sampler));
 
-        this.biomes = datapaletteblock;
+        this.biomes = block;
+        // Plazma end - Optimize noise
     }
 
     public LevelChunkSection copy() {
diff --git a/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java b/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
index 8b84bf2272556ac3321cbf16361d7f48a1cc6873..84047336fbd8833cc95bf5afa721f983aee97d4d 100644
--- a/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
+++ b/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
@@ -30,7 +30,7 @@ public class PalettedContainer<T> implements PaletteResize<T>, PalettedContainer
     public final IdMap<T> registry;
     private final T @org.jetbrains.annotations.Nullable [] presetValues; // Paper - Anti-Xray - Add preset values
     public volatile PalettedContainer.Data<T> data; // Paper - optimise collisions - public
-    private final PalettedContainer.Strategy strategy;
+    public final PalettedContainer.Strategy strategy; // Plazma - private -> public
     // private final ThreadingDetector threadingDetector = new ThreadingDetector("PalettedContainer"); // Paper - unused
 
     public void acquire() {
diff --git a/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java b/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
index 0346fd4ab7095d66c0eef5a440afbc7a8ba52466..35b589fa6d53cce957365e1cfcb5cf1978390546 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
@@ -51,6 +51,7 @@ import org.apache.commons.lang3.mutable.MutableObject;
 
 public final class NoiseBasedChunkGenerator extends ChunkGenerator {
 
+    public static boolean PLAZMA_USE_NOISIUM = false; // Plazma - Optimize noise chunk generation
     public static final MapCodec<NoiseBasedChunkGenerator> CODEC = RecordCodecBuilder.mapCodec((instance) -> {
         return instance.group(BiomeSource.CODEC.fieldOf("biome_source").forGetter((chunkgeneratorabstract) -> {
             return chunkgeneratorabstract.biomeSource;
@@ -270,6 +271,24 @@ public final class NoiseBasedChunkGenerator extends ChunkGenerator {
         int k = Mth.floorDiv(noisesettings.height(), noisesettings.getCellHeight());
 
         return k <= 0 ? CompletableFuture.completedFuture(chunk) : CompletableFuture.supplyAsync(() -> {
+            // Plazma start - Optimize noise chunk generation
+            if (PLAZMA_USE_NOISIUM) {
+                int l = chunk.getSectionIndex(k * noisesettings.getCellHeight() - 1 + i);
+                int i1 = chunk.getSectionIndex(i);
+
+                var set = chunk.getSections();
+                for (int j1 = l; j1 >= i1; --j1) set[j1].acquire();
+
+                ChunkAccess ichunkaccess1;
+                try {
+                    ichunkaccess1 = this.doFill(blender, structureAccessor, noiseConfig, chunk, j, k);
+                } finally {
+                    for (int j1 = l; j1 >= i1; --j1) set[j1].release();
+                }
+
+                return ichunkaccess1;
+            }
+            // Plazma end - Optimize noise chunk generation
             int l = chunk.getSectionIndex(k * noisesettings.getCellHeight() - 1 + i);
             int i1 = chunk.getSectionIndex(i);
             Set<LevelChunkSection> set = Sets.newHashSet();
@@ -377,6 +396,18 @@ public final class NoiseBasedChunkGenerator extends ChunkGenerator {
 
                                 iblockdata = this.debugPreliminarySurfaceLevel(noisechunk, j4, j3, i5, iblockdata);
                                 if (iblockdata != NoiseBasedChunkGenerator.AIR && !SharedConstants.debugVoidTerrain(chunk.getPos())) {
+                                    // Plazma start - Optimize noise
+                                    if (PLAZMA_USE_NOISIUM) {
+                                        var id = chunksection.states.data.palette().idFor(iblockdata);
+                                        chunksection.states.data.storage().getAndSet(chunksection.states.strategy.getIndex(k4, k3, j5), id);
+
+                                        ++chunksection.nonEmptyBlockCount;
+                                        if (iblockdata.isRandomlyTicking()) ++chunksection.tickingBlockCount;
+                                        if (iblockdata.getFluidState().isRandomlyTicking()) ++chunksection.tickingFluidCount;
+                                        if (ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.isSpecialCollidingBlock(iblockdata)) ++chunksection.specialCollidingBlocks;
+                                        if (chunksection.isRandomlyTicking()) chunksection.tickingBlocks.add((short) (k4 | (k3 << 4) | (j5 << (4+4))));
+                                    } else
+                                    // Plazma end - Optimize noise
                                     chunksection.setBlockState(k4, k3, j5, iblockdata, false);
                                     heightmap.update(k4, j3, j5, iblockdata);
                                     heightmap1.update(k4, j3, j5, iblockdata);
diff --git a/src/main/java/net/minecraft/world/level/levelgen/NoiseSettings.java b/src/main/java/net/minecraft/world/level/levelgen/NoiseSettings.java
index 932d1d9bd717b1176f8c82b0cf65d2eb6403ad40..a54a279cbaa30c58df572242ad5cf9786c715b66 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/NoiseSettings.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/NoiseSettings.java
@@ -8,7 +8,7 @@ import net.minecraft.core.QuartPos;
 import net.minecraft.world.level.LevelHeightAccessor;
 import net.minecraft.world.level.dimension.DimensionType;
 
-public record NoiseSettings(int minY, int height, int noiseSizeHorizontal, int noiseSizeVertical) {
+public record NoiseSettings(int minY, int height, int noiseSizeHorizontal, int noiseSizeVertical, int horizontalCellBlockCount, int verticalCellBlockCount) { // Plazma - Optimize noise
     public static final Codec<NoiseSettings> CODEC = RecordCodecBuilder.<NoiseSettings>create(
             instance -> instance.group(
                         Codec.intRange(DimensionType.MIN_Y, DimensionType.MAX_Y).fieldOf("min_y").forGetter(NoiseSettings::minY),
@@ -16,7 +16,7 @@ public record NoiseSettings(int minY, int height, int noiseSizeHorizontal, int n
                         Codec.intRange(1, 4).fieldOf("size_horizontal").forGetter(NoiseSettings::noiseSizeHorizontal),
                         Codec.intRange(1, 4).fieldOf("size_vertical").forGetter(NoiseSettings::noiseSizeVertical)
                     )
-                    .apply(instance, NoiseSettings::new)
+                    .apply(instance, NoiseSettings::create) // Plazma - Optimize noise
         )
         .comapFlatMap(NoiseSettings::guardY, Function.identity());
     protected static final NoiseSettings OVERWORLD_NOISE_SETTINGS = create(-64, 384, 1, 2);
@@ -36,7 +36,7 @@ public record NoiseSettings(int minY, int height, int noiseSizeHorizontal, int n
     }
 
     public static NoiseSettings create(int minimumY, int height, int horizontalSize, int verticalSize) {
-        NoiseSettings noiseSettings = new NoiseSettings(minimumY, height, horizontalSize, verticalSize);
+        NoiseSettings noiseSettings = new NoiseSettings(minimumY, height, horizontalSize, verticalSize, QuartPos.toBlock(horizontalSize), QuartPos.toBlock(verticalSize)); // Plazma - Optimize noise
         guardY(noiseSettings).error().ifPresent(error -> {
             throw new IllegalStateException(error.message());
         });
@@ -44,16 +44,16 @@ public record NoiseSettings(int minY, int height, int noiseSizeHorizontal, int n
     }
 
     public int getCellHeight() {
-        return QuartPos.toBlock(this.noiseSizeVertical());
+        return this.horizontalCellBlockCount; // Plazma - Optimize noise
     }
 
     public int getCellWidth() {
-        return QuartPos.toBlock(this.noiseSizeHorizontal());
+        return this.verticalCellBlockCount; // Plazma - Optimize noise
     }
 
     public NoiseSettings clampToHeightAccessor(LevelHeightAccessor world) {
         int i = Math.max(this.minY, world.getMinY());
         int j = Math.min(this.minY + this.height, world.getMaxY() + 1) - i;
-        return new NoiseSettings(i, j, this.noiseSizeHorizontal, this.noiseSizeVertical);
+        return new NoiseSettings(i, j, this.noiseSizeHorizontal, this.noiseSizeVertical, QuartPos.toBlock(this.noiseSizeHorizontal), QuartPos.toBlock(this.noiseSizeVertical)); // Plazma - Optimize noise
     }
 }
diff --git a/src/main/java/net/minecraft/world/level/levelgen/material/MaterialRuleList.java b/src/main/java/net/minecraft/world/level/levelgen/material/MaterialRuleList.java
index 0e6dfe2635ea5f5e410049b05f94f5083b2f18a4..584311a00c5037a6d5bc05b1261969aad1c38a4c 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/material/MaterialRuleList.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/material/MaterialRuleList.java
@@ -9,12 +9,15 @@ public record MaterialRuleList(NoiseChunk.BlockStateFiller[] materialRuleList) i
     @Nullable
     @Override
     public BlockState calculate(DensityFunction.FunctionContext pos) {
-        for (NoiseChunk.BlockStateFiller blockStateFiller : this.materialRuleList) {
-            BlockState blockState = blockStateFiller.calculate(pos);
-            if (blockState != null) {
-                return blockState;
-            }
+        // Plazma start - Optimize noise
+        //noinspection ForLoopReplaceableByForEach
+        for (int i = 0; i < this.materialRuleList.length; i++) {
+            BlockState state = this.materialRuleList[i].calculate(pos);
+            if (state == null) continue;
+
+            return state;
         }
+        // Plazma end - Optimize noise
 
         return null;
     }
diff --git a/src/main/java/org/plazmamc/plazma/configurations/GlobalConfiguration.java b/src/main/java/org/plazmamc/plazma/configurations/GlobalConfiguration.java
index e85e7b22e7b2e59897d4c35e2e5150c0a26235c6..dc300e14e1bd03b4e855a360f1deda1cd7d6f7f0 100644
--- a/src/main/java/org/plazmamc/plazma/configurations/GlobalConfiguration.java
+++ b/src/main/java/org/plazmamc/plazma/configurations/GlobalConfiguration.java
@@ -45,6 +45,8 @@ public class GlobalConfiguration extends ConfigurationPart {
     public WorldGeneration worldgen;
     public class WorldGeneration extends ConfigurationPart {
 
+        boolean useAlternativeNoiseGenerator = OPTIMIZE;
+
         public LavaSea lavaSea;
         public class LavaSea extends ConfigurationPart {
 
@@ -64,6 +66,11 @@ public class GlobalConfiguration extends ConfigurationPart {
 
         }
 
+        @PostProcess
+        void post() {
+            net.minecraft.world.level.levelgen.NoiseBasedChunkGenerator.PLAZMA_USE_NOISIUM = this.useAlternativeNoiseGenerator;
+        }
+
     }
 
     public Entity entity;
