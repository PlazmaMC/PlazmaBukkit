From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: AlphaKR93 <dev@alpha93.kr>
Date: Fri, 3 Nov 2023 00:11:50 +0900
Subject: [PATCH] Plazma Configurations


diff --git a/src/main/java/org/plazmamc/plazma/commands/Commands.java b/src/main/java/org/plazmamc/plazma/commands/Commands.java
new file mode 100644
index 0000000000000000000000000000000000000000..4497d8f8a52db0fc89ce27168b54657d172b1445
--- /dev/null
+++ b/src/main/java/org/plazmamc/plazma/commands/Commands.java
@@ -0,0 +1,23 @@
+package org.plazmamc.plazma.commands;
+
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.command.Command;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.plazmamc.plazma.commands.plazma.PlazmaCommand;
+
+import java.util.HashMap;
+import java.util.Map;
+
+@DefaultQualifier(NonNull.class)
+public class Commands {
+
+    private static final Map<String, Command> COMMANDS = new HashMap<>() {{
+        put("plazma", new PlazmaCommand("plazma"));
+    }};
+
+    public static void register(final MinecraftServer server) {
+        COMMANDS.forEach((s, command) -> server.server.getCommandMap().register(s, "Plazma", command));
+    }
+
+}
diff --git a/src/main/java/org/plazmamc/plazma/commands/PlazmaSubCommand.java b/src/main/java/org/plazmamc/plazma/commands/PlazmaSubCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..e25ba7935e2743aab5c1334c6582459556ec643a
--- /dev/null
+++ b/src/main/java/org/plazmamc/plazma/commands/PlazmaSubCommand.java
@@ -0,0 +1,19 @@
+package org.plazmamc.plazma.commands;
+
+import org.bukkit.command.CommandSender;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+import java.util.Collections;
+import java.util.List;
+
+@DefaultQualifier(NonNull.class)
+public interface PlazmaSubCommand {
+
+    boolean execute(final CommandSender sender, final String subCommand, final String[] args);
+
+    default List<String> tabComplete(final CommandSender sender, final String subCommand, final String[] args) {
+        return Collections.emptyList();
+    }
+
+}
diff --git a/src/main/java/org/plazmamc/plazma/commands/plazma/PlazmaCommand.java b/src/main/java/org/plazmamc/plazma/commands/plazma/PlazmaCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..1628bee2fb106ad149cad95fb5e3d1100448c697
--- /dev/null
+++ b/src/main/java/org/plazmamc/plazma/commands/plazma/PlazmaCommand.java
@@ -0,0 +1,120 @@
+package org.plazmamc.plazma.commands.plazma;
+
+import io.papermc.paper.command.CommandUtil;
+import it.unimi.dsi.fastutil.Pair;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.minecraft.Util;
+import org.bukkit.Bukkit;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionDefault;
+import org.bukkit.plugin.PluginManager;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.plazmamc.plazma.commands.PlazmaSubCommand;
+import org.plazmamc.plazma.commands.plazma.subcommand.ReloadCommand;
+import org.plazmamc.plazma.commands.plazma.subcommand.VersionCommand;
+
+import java.util.*;
+import java.util.stream.Collectors;
+
+import static net.kyori.adventure.text.Component.text;
+
+@DefaultQualifier(NonNull.class)
+public class PlazmaCommand extends Command {
+
+    private static final Map<String, PlazmaSubCommand> SUB_COMMANDS = Util.make(() -> {
+        final Map<Set<String>, PlazmaSubCommand> commands = new HashMap<>() {{
+            put(Set.of("reload"), new ReloadCommand());
+            put(Set.of("version"), new VersionCommand());
+        }};
+
+        return commands.entrySet().stream()
+                .flatMap(entry -> entry.getKey().stream().map(key -> Map.entry(key, entry.getValue())))
+                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
+    });
+
+    private static final Map<String, String> ALIASES = Util.make(() -> {
+        final Map<String, Set<String>> aliases = new HashMap<>() {{
+            put("reload", Set.of("rl"));
+            put("version", Set.of("ver"));
+        }};
+
+        return aliases.entrySet().stream()
+                .flatMap(entry -> entry.getValue().stream().map(s -> Map.entry(s, entry.getKey())))
+                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
+    });
+
+    public PlazmaCommand(final String name) {
+        super(name);
+
+        final PluginManager pluginManager = Bukkit.getServer().getPluginManager();
+
+        final List<String> permissions = new ArrayList<>();
+        permissions.add("bukkit.command.plazma");
+        permissions.addAll(SUB_COMMANDS.keySet().stream().map(s -> "bukkit.command.plazma." + s).toList());
+
+        this.description = "Plazma related commands";
+        this.usageMessage = String.format("/plazma [%s]", String.join("|", SUB_COMMANDS.keySet()));
+        this.setPermission(String.join(";", permissions));
+
+        permissions.forEach(perm -> pluginManager.addPermission(new Permission(perm, PermissionDefault.OP)));
+    }
+
+    @Override
+    public boolean execute(final CommandSender sender, final String commandLabel, final String[] args) {
+        if (!testPermission(sender)) return true;
+
+        if (args.length == 0) {
+            sender.sendMessage(text("Usage: " + this.usageMessage, NamedTextColor.RED));
+            return false;
+        }
+
+        final @Nullable Pair<String, PlazmaSubCommand> subCommand = resolveSubCommand(args[0]);
+
+        if (subCommand == null) {
+            sender.sendMessage(text("Usage: " + this.usageMessage, NamedTextColor.RED));
+            return false;
+        }
+
+        if (!testPermission(sender, subCommand.first())) return true;
+
+        final String[] choppedArgs = Arrays.copyOfRange(args, 1, args.length);
+        return subCommand.second().execute(sender, subCommand.first(), choppedArgs);
+    }
+
+    @Override
+    public List<String> tabComplete(final CommandSender sender, final String aliases, final String[] args) throws IllegalArgumentException {
+        if (args.length <= 1) return CommandUtil.getListMatchingLast(sender, args, SUB_COMMANDS.keySet());
+
+        final @Nullable Pair<String, PlazmaSubCommand> subCommand = resolveSubCommand(args[0]);
+
+        if (subCommand != null) return subCommand.second().tabComplete(sender, subCommand.first(), Arrays.copyOfRange(args, 1, args.length));
+        return Collections.emptyList();
+    }
+
+    private static boolean testPermission(final CommandSender sender, final String permission) {
+        if (sender.hasPermission("bukkit.command.plazma." + permission) || sender.hasPermission("bukkit.command.plazma")) return true;
+        sender.sendMessage(Bukkit.permissionMessage());
+        return false;
+    }
+
+    private static @Nullable Pair<String, PlazmaSubCommand> resolveSubCommand(String label) {
+        label = label.toLowerCase(Locale.ENGLISH);
+        @Nullable PlazmaSubCommand subCommand = SUB_COMMANDS.get(label);
+
+        if (subCommand == null) {
+            final @Nullable String command = ALIASES.get(label);
+            if (command != null) {
+                label = command;
+                subCommand = SUB_COMMANDS.get(label);
+            }
+        }
+
+        if (subCommand != null) return Pair.of(label, subCommand);
+        return null;
+    }
+
+}
diff --git a/src/main/java/org/plazmamc/plazma/commands/plazma/subcommand/ReloadCommand.java b/src/main/java/org/plazmamc/plazma/commands/plazma/subcommand/ReloadCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..1c83926923f50fb4da1a83dc91614c20a831555f
--- /dev/null
+++ b/src/main/java/org/plazmamc/plazma/commands/plazma/subcommand/ReloadCommand.java
@@ -0,0 +1,34 @@
+package org.plazmamc.plazma.commands.plazma.subcommand;
+
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.CraftServer;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.plazmamc.plazma.commands.PlazmaSubCommand;
+
+import static net.kyori.adventure.text.Component.text;
+
+@DefaultQualifier(NonNull.class)
+public class ReloadCommand implements PlazmaSubCommand {
+
+    @Override
+    public boolean execute(final CommandSender sender, final String subCommand, final String[] args) {
+        this.reload(sender);
+        return true;
+    }
+
+    private void reload(final CommandSender sender) {
+        Command.broadcastCommandMessage(sender, text("Please note that this command is not supported and may cause issues.", NamedTextColor.RED));
+        Command.broadcastCommandMessage(sender, text("If you encounter any issues please use the /stop command to restart your server.", NamedTextColor.RED));
+
+        MinecraftServer server = ((CraftServer) sender.getServer()).getServer();
+        server.plazmaConfigurations.reloadConfigs(server);
+        server.server.reloadCount++;
+
+        Command.broadcastCommandMessage(sender, text("Successfully reloaded Plazma configuration files.", NamedTextColor.GREEN));
+    }
+
+}
diff --git a/src/main/java/org/plazmamc/plazma/commands/plazma/subcommand/VersionCommand.java b/src/main/java/org/plazmamc/plazma/commands/plazma/subcommand/VersionCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..b6664ba0fce55f5cfa0c8d3051dc8c2be0fd0703
--- /dev/null
+++ b/src/main/java/org/plazmamc/plazma/commands/plazma/subcommand/VersionCommand.java
@@ -0,0 +1,21 @@
+package org.plazmamc.plazma.commands.plazma.subcommand;
+
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.plazmamc.plazma.commands.PlazmaSubCommand;
+
+@DefaultQualifier(NonNull.class)
+public class VersionCommand implements PlazmaSubCommand {
+
+    @Override
+    public boolean execute(final CommandSender sender, final String subCommand, final String[] args) {
+        final @Nullable Command ver = MinecraftServer.getServer().server.getCommandMap().getCommand("version");
+        if (ver != null) return ver.execute(sender, "plazma", new String[0]);
+        return false;
+    }
+
+}
diff --git a/src/test/java/org/bukkit/support/DummyServerHelper.java b/src/test/java/org/bukkit/support/DummyServerHelper.java
index 309d371247adcddf0a1b370cc5faff3e6e01cb0f..285a90ff5cdc8cb28fafd4ea3dae306ae5b899c9 100644
--- a/src/test/java/org/bukkit/support/DummyServerHelper.java
+++ b/src/test/java/org/bukkit/support/DummyServerHelper.java
@@ -92,6 +92,7 @@ public final class DummyServerHelper {
         // Paper end - testing additions
 
         io.papermc.paper.configuration.GlobalConfigTestingBase.setupGlobalConfigForTest(); // Paper - configuration files - setup global configuration test base
+        org.plazmamc.plazma.configurations.GlobalConfigurationTestingBase.setupGlobalConfigForTest(); // Plazma - Configurable Plazma
 
         // Paper start - add test for recipe conversion
         when(instance.recipeIterator()).thenAnswer(ignored ->
diff --git a/src/test/java/org/plazmamc/plazma/configurations/GlobalConfigurationTestingBase.java b/src/test/java/org/plazmamc/plazma/configurations/GlobalConfigurationTestingBase.java
new file mode 100644
index 0000000000000000000000000000000000000000..c63942e2dc00ed6d6b4119f418bdaa5a64b4c0fe
--- /dev/null
+++ b/src/test/java/org/plazmamc/plazma/configurations/GlobalConfigurationTestingBase.java
@@ -0,0 +1,20 @@
+package org.plazmamc.plazma.configurations;
+
+import org.spongepowered.configurate.ConfigurationNode;
+import org.spongepowered.configurate.serialize.SerializationException;
+
+public class GlobalConfigurationTestingBase {
+
+    public static void setupGlobalConfigForTest() {
+        if (GlobalConfiguration.get() == null) {
+            ConfigurationNode node = PlazmaConfigurations.createForTesting();
+            try {
+                GlobalConfiguration globalConfiguration = node.require(GlobalConfiguration.class);
+                GlobalConfiguration.set(globalConfiguration);
+            } catch (SerializationException e) {
+                throw new RuntimeException(e);
+            }
+        }
+    }
+
+}
