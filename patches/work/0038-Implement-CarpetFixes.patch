From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?IPECTER=20=EC=9D=B4=ED=8C=A9=ED=84=B0?=
 <80433772+IPECTER@users.noreply.github.com>
Date: Wed, 21 Aug 2024 16:16:22 +0900
Subject: [PATCH] Implement-CarpetFixes


diff --git a/src/main/java/net/minecraft/world/entity/animal/Sheep.java b/src/main/java/net/minecraft/world/entity/animal/Sheep.java
index 658f7943d275267d3fc556572831cc095259d12e..8ad02b079c729320f5968eee5e6284371d11250e 100644
--- a/src/main/java/net/minecraft/world/entity/animal/Sheep.java
+++ b/src/main/java/net/minecraft/world/entity/animal/Sheep.java
@@ -460,17 +460,25 @@ public class Sheep extends Animal implements Shearable {
     private DyeColor getOffspringColor(Animal firstParent, Animal secondParent) {
         DyeColor enumcolor = ((Sheep) firstParent).getColor();
         DyeColor enumcolor1 = ((Sheep) secondParent).getColor();
-        CraftingContainer inventorycrafting = Sheep.makeContainer(enumcolor, enumcolor1);
-        Optional<Item> optional = this.level().getRecipeManager().getRecipeFor(RecipeType.CRAFTING, inventorycrafting, this.level()).map((recipeholder) -> { // CraftBukkit - decompile error
-            return ((CraftingRecipe) recipeholder.value()).assemble(inventorycrafting, this.level().registryAccess());
-        }).map(ItemStack::getItem);
-
-        Objects.requireNonNull(DyeItem.class);
-        optional = optional.filter(DyeItem.class::isInstance);
-        Objects.requireNonNull(DyeItem.class);
-        return (DyeColor) optional.map(DyeItem.class::cast).map(DyeItem::getDyeColor).orElseGet(() -> {
-            return this.level().random.nextBoolean() ? enumcolor : enumcolor1;
-        });
+        // Plazma start - Implement CarpetFixes
+        if (this.level().plazmaConfig().carpetFixes.preparedSheepChildColor()) {
+            DyeColor col = org.plazmamc.plazma.util.CarpetFixesUtils.properDyeMixin(enumcolor, enumcolor1);
+            if (col == null) col = this.level().random.nextBoolean() ? enumcolor : enumcolor1;
+            return col;
+        } else {
+            CraftingContainer inventorycrafting = Sheep.makeContainer(enumcolor, enumcolor1);
+            Optional<Item> optional = this.level().getRecipeManager().getRecipeFor(RecipeType.CRAFTING, inventorycrafting, this.level()).map((recipeholder) -> { // CraftBukkit - decompile error
+                return ((CraftingRecipe) recipeholder.value()).assemble(inventorycrafting, this.level().registryAccess());
+            }).map(ItemStack::getItem);
+
+            Objects.requireNonNull(DyeItem.class);
+            optional = optional.filter(DyeItem.class::isInstance);
+            Objects.requireNonNull(DyeItem.class);
+            return (DyeColor) optional.map(DyeItem.class::cast).map(DyeItem::getDyeColor).orElseGet(() -> {
+                return this.level().random.nextBoolean() ? enumcolor : enumcolor1;
+            });
+        }
+        // Plazma end
     }
 
     private static CraftingContainer makeContainer(DyeColor firstColor, DyeColor secondColor) {
diff --git a/src/main/java/net/minecraft/world/item/crafting/RecipeManager.java b/src/main/java/net/minecraft/world/item/crafting/RecipeManager.java
index 681e3fcd759a26578e054f88e8048e392312b84b..253819783d577c4c2abe737e0c76ac88121387db 100644
--- a/src/main/java/net/minecraft/world/item/crafting/RecipeManager.java
+++ b/src/main/java/net/minecraft/world/item/crafting/RecipeManager.java
@@ -137,7 +137,7 @@ public class RecipeManager extends SimpleJsonResourceReloadListener {
     }
 
     public <C extends Container, T extends Recipe<C>> List<RecipeHolder<T>> getAllRecipesFor(RecipeType<T> type) {
-        return List.copyOf(this.byType(type).values());
+        return org.plazmamc.plazma.configurations.GlobalConfiguration.get().carpetFixes.fasterRecipeList() ? new java.util.ArrayList<>(this.byType(type).values()) :  List.copyOf(this.byType(type).values()); // Plazma - Implement CarpetFixes
     }
 
     public <C extends Container, T extends Recipe<C>> List<RecipeHolder<T>> getRecipesFor(RecipeType<T> type, C inventory, Level world) {
diff --git a/src/main/java/net/minecraft/world/level/biome/BiomeManager.java b/src/main/java/net/minecraft/world/level/biome/BiomeManager.java
index 01352cc83b25eb0e30b7e0ff521fc7c1b3d5155b..e6544cf89bc5e85d9b7fb9b278ffc765c5268f37 100644
--- a/src/main/java/net/minecraft/world/level/biome/BiomeManager.java
+++ b/src/main/java/net/minecraft/world/level/biome/BiomeManager.java
@@ -12,6 +12,7 @@ public class BiomeManager {
     private static final int ZOOM_BITS = 2;
     private static final int ZOOM = 4;
     private static final int ZOOM_MASK = 3;
+    private static final double maxOffset = 0.4500000001D; // Plazma - Implement CarpetFixes
     private final BiomeManager.NoiseBiomeSource noiseBiomeSource;
     private final long biomeZoomSeed;
 
@@ -29,39 +30,104 @@ public class BiomeManager {
     }
 
     public Holder<Biome> getBiome(BlockPos pos) {
-        int i = pos.getX() - 2;
-        int j = pos.getY() - 2;
-        int k = pos.getZ() - 2;
-        int l = i >> 2;
-        int m = j >> 2;
-        int n = k >> 2;
-        double d = (double)(i & 3) / 4.0;
-        double e = (double)(j & 3) / 4.0;
-        double f = (double)(k & 3) / 4.0;
-        int o = 0;
-        double g = Double.POSITIVE_INFINITY;
-
-        for (int p = 0; p < 8; p++) {
-            boolean bl = (p & 4) == 0;
-            boolean bl2 = (p & 2) == 0;
-            boolean bl3 = (p & 1) == 0;
-            int q = bl ? l : l + 1;
-            int r = bl2 ? m : m + 1;
-            int s = bl3 ? n : n + 1;
-            double h = bl ? d : d - 1.0;
-            double t = bl2 ? e : e - 1.0;
-            double u = bl3 ? f : f - 1.0;
-            double v = getFiddledDistance(this.biomeZoomSeed, q, r, s, h, t, u);
-            if (g > v) {
-                o = p;
-                g = v;
+        // Plazma start - Implement CarpetFixes
+        if (org.plazmamc.plazma.configurations.GlobalConfiguration.get().carpetFixes.optimizedBiomeAccess()) {
+            int xMinus2 = pos.getX() - 2;
+            int yMinus2 = pos.getY() - 2;
+            int zMinus2 = pos.getZ() - 2;
+            int x = xMinus2 >> 2; // BlockPos to BiomePos
+            int y = yMinus2 >> 2;
+            int z = zMinus2 >> 2;
+            double quartX = (double) (xMinus2 & 3) / 4.0D; // quartLocal divided by 4
+            double quartY = (double) (yMinus2 & 3) / 4.0D; // 0/4, 1/4, 2/4, 3/4
+            double quartZ = (double) (zMinus2 & 3) / 4.0D; // [0, 0.25, 0.5, 0.75]
+            int smallestX = 0;
+            double smallestDist = Double.POSITIVE_INFINITY;
+            for (int biomeX = 0; biomeX < 8; ++biomeX) {
+                boolean everyOtherQuad = (biomeX & 4) == 0; // 1 1 1 1 0 0 0 0
+                boolean everyOtherPair = (biomeX & 2) == 0; // 1 1 0 0 1 1 0 0
+                boolean everyOther = (biomeX & 1) == 0; // 1 0 1 0 1 0 1 0
+                double quartXX = everyOtherQuad ? quartX : quartX - 1.0D; //[-1.0,-0.75,-0.5,-0.25,0.0,0.25,0.5,0.75]
+                double quartYY = everyOtherPair ? quartY : quartY - 1.0D;
+                double quartZZ = everyOther ? quartZ : quartZ - 1.0D;
+
+                //This code block is new
+                double maxQuartYY = 0.0D, maxQuartZZ = 0.0D;
+                if (biomeX != 0) {
+                    maxQuartYY = Mth.square(Math.max(quartYY + maxOffset, Math.abs(quartYY - maxOffset)));
+                    maxQuartZZ = Mth.square(Math.max(quartZZ + maxOffset, Math.abs(quartZZ - maxOffset)));
+                    double maxQuartXX = Mth.square(Math.max(quartXX + maxOffset, Math.abs(quartXX - maxOffset)));
+                    if (smallestDist < maxQuartXX + maxQuartYY + maxQuartZZ) continue;
+                }
+
+                int xx = everyOtherQuad ? x : x + 1;
+                int yy = everyOtherPair ? y : y + 1;
+                int zz = everyOther ? z : z + 1;
+
+                //I transferred the code from method_38106 to here, so I could call continue halfway through
+                long seed = LinearCongruentialGenerator.next(this.biomeZoomSeed, xx);
+                seed = LinearCongruentialGenerator.next(seed, yy);
+                seed = LinearCongruentialGenerator.next(seed, zz);
+                seed = LinearCongruentialGenerator.next(seed, xx);
+                seed = LinearCongruentialGenerator.next(seed, yy);
+                seed = LinearCongruentialGenerator.next(seed, zz);
+                double offsetX = getFiddle(seed);
+                double sqrX = Mth.square(quartXX + offsetX);
+                if (biomeX != 0 && smallestDist < sqrX + maxQuartYY + maxQuartZZ) continue; //skip the rest of the loop
+                seed = LinearCongruentialGenerator.next(seed, this.biomeZoomSeed);
+                double offsetY = getFiddle(seed);
+                double sqrY = Mth.square(quartYY + offsetY);
+                if (biomeX != 0 && smallestDist < sqrX + sqrY + maxQuartZZ) continue; // skip the rest of the loop
+                seed = LinearCongruentialGenerator.next(seed, this.biomeZoomSeed);
+                double offsetZ = getFiddle(seed);
+                double biomeDist = sqrX + sqrY + Mth.square(quartZZ + offsetZ);
+
+                if (smallestDist > biomeDist) {
+                    smallestX = biomeX;
+                    smallestDist = biomeDist;
+                }
+            }
+            return this.noiseBiomeSource.getNoiseBiome(
+                (smallestX & 4) == 0 ? x : x + 1,
+                (smallestX & 2) == 0 ? y : y + 1,
+                (smallestX & 1) == 0 ? z : z + 1
+            );
+        } else {
+            int i = pos.getX() - 2;
+            int j = pos.getY() - 2;
+            int k = pos.getZ() - 2;
+            int l = i >> 2;
+            int m = j >> 2;
+            int n = k >> 2;
+            double d = (double) (i & 3) / 4.0;
+            double e = (double) (j & 3) / 4.0;
+            double f = (double) (k & 3) / 4.0;
+            int o = 0;
+            double g = Double.POSITIVE_INFINITY;
+
+            for (int p = 0; p < 8; p++) {
+                boolean bl = (p & 4) == 0;
+                boolean bl2 = (p & 2) == 0;
+                boolean bl3 = (p & 1) == 0;
+                int q = bl ? l : l + 1;
+                int r = bl2 ? m : m + 1;
+                int s = bl3 ? n : n + 1;
+                double h = bl ? d : d - 1.0;
+                double t = bl2 ? e : e - 1.0;
+                double u = bl3 ? f : f - 1.0;
+                double v = getFiddledDistance(this.biomeZoomSeed, q, r, s, h, t, u);
+                if (g > v) {
+                    o = p;
+                    g = v;
+                }
             }
-        }
 
-        int w = (o & 4) == 0 ? l : l + 1;
-        int x = (o & 2) == 0 ? m : m + 1;
-        int y = (o & 1) == 0 ? n : n + 1;
-        return this.noiseBiomeSource.getNoiseBiome(w, x, y);
+            int w = (o & 4) == 0 ? l : l + 1;
+            int x = (o & 2) == 0 ? m : m + 1;
+            int y = (o & 1) == 0 ? n : n + 1;
+            return this.noiseBiomeSource.getNoiseBiome(w, x, y);
+        }
+        // Plazma end
     }
 
     public Holder<Biome> getNoiseBiomeAtPosition(double x, double y, double z) {
diff --git a/src/main/java/org/plazmamc/plazma/configurations/GlobalConfiguration.java b/src/main/java/org/plazmamc/plazma/configurations/GlobalConfiguration.java
index 98f26e3de66a881163e84295e9156c7f362bf7cb..9af184b55fd32d16194b669c42bfbf9b18e96e26 100644
--- a/src/main/java/org/plazmamc/plazma/configurations/GlobalConfiguration.java
+++ b/src/main/java/org/plazmamc/plazma/configurations/GlobalConfiguration.java
@@ -109,4 +109,21 @@ public class GlobalConfiguration extends ConfigurationPart {
 
     }
 
+    public CarpetFixes carpetFixes;
+    public class CarpetFixes extends ConfigurationPart {
+
+        public boolean enabled = OPTIMIZE;
+        boolean optimizedBiomeAccess = true;
+        boolean fasterRecipeList = true;
+
+        public boolean optimizedBiomeAccess() {
+            return enabled && optimizedBiomeAccess;
+        }
+
+        public boolean fasterRecipeList() {
+            return enabled && fasterRecipeList;
+        }
+
+    }
+
 }
diff --git a/src/main/java/org/plazmamc/plazma/configurations/WorldConfigurations.java b/src/main/java/org/plazmamc/plazma/configurations/WorldConfigurations.java
index 6a0cfec24618227d9a5ddc6c71e37d1986147799..9d6d4400be8bf189308cbd0cb14afa1ff0191a57 100644
--- a/src/main/java/org/plazmamc/plazma/configurations/WorldConfigurations.java
+++ b/src/main/java/org/plazmamc/plazma/configurations/WorldConfigurations.java
@@ -90,4 +90,16 @@ public class WorldConfigurations extends ConfigurationPart {
 
     }
 
+    public CarpetFixes carpetFixes;
+    public class CarpetFixes extends ConfigurationPart {
+
+        public boolean enabled = OPTIMIZE;
+        boolean preparedSheepChildColor = true;
+
+        public boolean preparedSheepChildColor() {
+            return enabled && preparedSheepChildColor;
+        }
+
+    }
+
 }
diff --git a/src/main/java/org/plazmamc/plazma/util/CarpetFixesUtils.java b/src/main/java/org/plazmamc/plazma/util/CarpetFixesUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..5d6deb61ef10039a551849e9b83798916f1dc58c
--- /dev/null
+++ b/src/main/java/org/plazmamc/plazma/util/CarpetFixesUtils.java
@@ -0,0 +1,48 @@
+package org.plazmamc.plazma.util;
+
+import net.minecraft.world.item.DyeColor;
+
+public class CarpetFixesUtils {
+
+    //If I was actually implementing this, the color values would have been binary in order for fast calculations.
+    //Never do this in a production build, although this is better than using the RecipeManager xD
+    public static DyeColor properDyeMixin(DyeColor col1, DyeColor col2) {
+        if (col1.equals(col2)) return col1;
+        switch(col1) {
+            case WHITE -> {
+                switch(col2) {
+                    case BLUE -> {return DyeColor.LIGHT_BLUE;}
+                    case GRAY -> {return DyeColor.LIGHT_GRAY;}
+                    case BLACK -> {return DyeColor.GRAY;}
+                    case GREEN -> {return DyeColor.LIME;}
+                    case RED -> {return DyeColor.PINK;}
+                }
+            }
+            case BLUE -> {
+                switch(col2) {
+                    case WHITE -> {return DyeColor.LIGHT_BLUE;}
+                    case GREEN -> {return DyeColor.CYAN;}
+                    case RED -> {return DyeColor.PURPLE;}
+                }
+            }
+            case RED -> {
+                switch(col2) {
+                    case YELLOW -> {return DyeColor.ORANGE;}
+                    case WHITE -> {return DyeColor.PINK;}
+                    case BLUE -> {return DyeColor.PURPLE;}
+                }
+            }case GREEN -> {
+                switch(col2) {
+                    case BLUE -> {return DyeColor.CYAN;}
+                    case WHITE -> {return DyeColor.LIME;}
+                }
+            }
+            case YELLOW -> {if (col2.equals(DyeColor.RED)) return DyeColor.ORANGE;}
+            case PURPLE -> {if (col2.equals(DyeColor.PINK)) return DyeColor.MAGENTA;}
+            case PINK -> {if (col2.equals(DyeColor.PURPLE)) return DyeColor.MAGENTA;}
+            case GRAY -> {if (col2.equals(DyeColor.WHITE)) return DyeColor.LIGHT_GRAY;}
+            case BLACK -> {if (col2.equals(DyeColor.WHITE)) return DyeColor.GRAY;}
+        }
+        return null;
+    }
+}
\ No newline at end of file
